<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="记录leetcode的上做过的一些题的解法思路，防止忘掉">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题笔记">
<meta property="og:url" content="http://yoursite.com/2019/03/30/leetcode刷题笔记/index.html">
<meta property="og:site_name" content="CoderZWei&#39;s blog">
<meta property="og:description" content="记录leetcode的上做过的一些题的解法思路，防止忘掉">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-06-09T03:32:34.273Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="leetcode刷题笔记">
<meta name="twitter:description" content="记录leetcode的上做过的一些题的解法思路，防止忘掉">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/30/leetcode刷题笔记/"/>





  <title>leetcode刷题笔记 | CoderZWei's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CoderZWei's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/30/leetcode刷题笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderZWei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/panpan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoderZWei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">leetcode刷题笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-30T19:17:26+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>记录leetcode的上做过的一些题的解法思路，防止忘掉</p>
<a id="more"></a>
<p>#####Path Sum II_113</p>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>解法：用深搜</p>
<blockquote>
<p>void dfs(TreeNode *root, vector<vector<int>&gt;&amp; res,vector<int>&amp;path,int tmp,int sum){<br>     if(root==NULL){<br>         return;<br>     }<br>     tmp+=root-&gt;val;<br>     path.push_back(root-&gt;val);<br>     if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL &amp;&amp; tmp==sum){<br>         res.push_back(path);<br>     }<br>     dfs(root-&gt;left,res,path,tmp,sum);<br>     dfs(root-&gt;right,res,path,tmp,sum);<br>     path.pop_back();<br> }</int></vector<int></p>
</blockquote>
<p>#####最长回文字符串_5</p>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p>解法：用动态规划</p>
<blockquote>
<p>string longestPalindrome(string s) {<br>    if(s.empty()){<br>        return “”;<br>    }<br>    int len=s.size();<br>    int dp[len][len]={0};<br>    int left=0,right=0,maxLen=0;<br>    for(int i=0;i&lt;len;++i){<br>        for(int j=0;j&lt;i;++j){</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;         if(s[i]==s[j] &amp;&amp; (i-j&lt;2 || dp[j+1][i-1]==1))&#123;</div><div class="line">&gt;             dp[j][i]=1;</div><div class="line">&gt;         &#125;else&#123;</div><div class="line">&gt;             dp[j][i]=0;</div><div class="line">&gt;         &#125;</div><div class="line">&gt;          //dp[j][i] = (s[i] == s[j] &amp;&amp; (i - j &lt; 2 || dp[j + 1][i - 1]));</div><div class="line">&gt;         if(dp[j][i]==1 &amp;&amp; i-j+1&gt;maxLen)&#123;</div><div class="line">&gt;             maxLen=i-j+1;</div><div class="line">&gt;             left=j;</div><div class="line">&gt;             right=i;</div><div class="line">&gt;         &#125;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;     dp[i][i]=1;</div><div class="line">&gt; &#125;</div><div class="line">&gt; return s.substr(left,right-left+1);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>}</p>
</blockquote>
<p>#####最接近的三数之和_16</p>
<p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>解法：</p>
<blockquote>
<p>int threeSumClosest(vector<int>&amp; nums, int target) {<br>     int minDiff=abs(nums[0]+nums[1]+nums[2]-target);<br>     int res=nums[0]+nums[1]+nums[2];<br>     sort(nums.begin(),nums.end());<br>     for(int i=0;i&lt;nums.size()-2;i++){<br>         //int tmp=abs(target-nums[i]);<br>         int left=i+1,right=nums.size()-1;<br>         while(left&lt;right){<br>             int sum=nums[i]+nums[left]+nums[right];<br>             if(abs(sum-target)&lt;minDiff){<br>                 minDiff=abs(sum-target);<br>                 res=sum;<br>             }<br>             if(sum&lt;target){<br>                 left++;<br>             }else{<br>                 right–;<br>             }<br>         }<br>     }<br>     return res;</int></p>
</blockquote>
<p>#####盛最多水的容器_11</p>
<p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em>条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p>
<p>解法：</p>
<blockquote>
<p>int maxArea(vector<int>&amp; height) {<br>     int left=0,right=height.size()-1;<br>     int res=0;<br>     while(left<right){ if(="" (right-left)\*(="" min(height[right],height[left])="" )="">res){<br>             res=(right-left)*( min(height[right],height[left]) );<br>         }<br>         if(height[left]&lt;height[right]){<br>             left++;<br>         }else{<br>             right–;<br>         }<br>     }<br>     return res;<br> }</right){></int></p>
</blockquote>
<p>#####括号生成_22</p>
<p>给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p>
<p>解法：用递归</p>
<blockquote>
<p>vector<string> generateParenthesis(int n) {<br>     vector<string>res;<br>     generate(n,n,””,res);<br>     return res;<br> }<br> void generate(int left,int right,string tmp,vector<string>&amp;res){<br>     if(left&gt;right){<br>         return;<br>     }<br>     else if(left==0 &amp;&amp; right==0){<br>         res.push_back(tmp);<br>     }else{<br>         if(left&gt;0){<br>             generate(left-1,right,tmp+’(‘,res);<br>         }<br>         if(right&gt;0){<br>             generate(left,right-1,tmp+’)’,res);<br>         }<br>     }</string></string></string></p>
<p>}</p>
</blockquote>
<p>#####全排列_46</p>
<p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">输入: [1,2,3]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [1,3,2],</div><div class="line">  [2,1,3],</div><div class="line">  [2,3,1],</div><div class="line">  [3,1,2],</div><div class="line">  [3,2,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>解法：用深搜，用visited标记，因为循环是从0开始</p>
<blockquote>
<p>vector<vector<int>&gt; permute(vector<int>&amp; nums) {<br>     sort(nums.begin(),nums.end());<br>     vector<vector<int>&gt;res;<br>     vector<int>tmp;<br>     vector<int> visited(nums.size(),0);<br>     dfs(res,tmp,0,nums,visited);<br>     return res;<br> }<br> void dfs(vector<vector<int>&gt;&amp;res,vector<int>tmp,int level,vector<int>nums,vector<int>visited){<br>     if(level==nums.size()){<br>         res.push_back(tmp);<br>         return;<br>     }<br>     for(int i=0;i&lt;nums.size();i++){<br>         if(visited[i]==1){<br>             continue;<br>         }<br>         visited[i]=1;<br>         tmp.push_back(nums[i]);<br>         dfs(res,tmp,i+1,nums,visited);<br>         tmp.pop_back();<br>         visited[i]=0;<br>     }<br>     return;<br> }</int></int></int></vector<int></int></int></vector<int></int></vector<int></p>
</blockquote>
<p>#####全排列II_47</p>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入: [1,1,2]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [1,1,2],</div><div class="line">  [1,2,1],</div><div class="line">  [2,1,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>解法：用深搜，有点儿麻烦</p>
<blockquote>
<p>vector<vector<int>&gt; permuteUnique(vector<int>&amp; nums) {<br>     sort(nums.begin(),nums.end());<br>     vector<vector<int>&gt;res;<br>     vector<int>tmp;<br>     vector<int>visited(nums.size(),0);<br>     if(nums.empty()){<br>         return res;<br>     }<br>     dfs(res,tmp,nums,visited,0);<br>     return res;<br> }<br> void dfs(vector<vector<int>&gt;&amp;res,vector<int>&amp;tmp,vector<int>nums,vector<int>&amp;visited,int level){<br>     if(level==nums.size()){<br>         res.push_back(tmp);<br>         return ;<br>     }<br>     for(int i=0;i<nums.size();i++){ if(visited[i]="=1){" continue;="" }="" if(i="">0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; visited[i-1]==0){<br>             continue;<br>         }<br>         tmp.push_back(nums[i]);<br>         visited[i]=1;<br>         dfs(res,tmp,nums,visited,level+1);<br>         tmp.pop_back();<br>         visited[i]=0;<br>     }<br>     return;<br> }</nums.size();i++){></int></int></int></vector<int></int></int></vector<int></int></vector<int></p>
</blockquote>
<p>#####子集_78</p>
<p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">输入: nums = [1,2,3]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [3],</div><div class="line">  [1],</div><div class="line">  [2],</div><div class="line">  [1,2,3],</div><div class="line">  [1,3],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure>
<p>解法：用深搜，循环从index开始</p>
<blockquote>
<p>vector<vector<int>&gt; subsets(vector<int>&amp; nums) {<br>    //<a href="http://www.cnblogs.com/grandyang/p/4309345.html" target="_blank" rel="external">http://www.cnblogs.com/grandyang/p/4309345.html</a><br>    sort(nums.begin(),nums.end());<br>    vector<vector<int>&gt;res;<br>    vector<int>tmp;<br>    dfs(res,tmp,nums,0);<br>    return res;<br>}</int></vector<int></int></vector<int></p>
<p>void dfs(vector<vector<int>&gt;&amp;res,vector<int>&amp;tmp,vector<int>nums,int index){<br>        res.push_back(tmp);</int></int></vector<int></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; for(int i=index;i&lt;nums.size();i++)&#123;</div><div class="line">&gt;     tmp.push_back(nums[i]);</div><div class="line">&gt;     dfs(res,tmp,nums,i+1);</div><div class="line">&gt;     tmp.pop_back();</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>}</p>
</blockquote>
<p>#####子集||_90</p>
<p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p>
<p>解法：用深搜加条件判断</p>
<blockquote>
<p>vector<vector<int>&gt; subsetsWithDup(vector<int>&amp; nums) {<br>     sort(nums.begin(),nums.end());<br>     vector<vector<int>&gt;res;<br>     vector<int>tmp;<br>    vector<int>visited(nums.size(),0);<br>     dfs(res,tmp,nums,0,visited);<br>     return res;<br> }<br> void dfs(vector<vector<int>&gt;&amp;res,vector<int>tmp,vector<int>&amp; nums,int level,vector<int>&amp;visited){<br>     res.push_back(tmp);<br>     for(int i=level;i<nums.size();i++){ if(i="">0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; visited[i-1]==0){<br>             continue;<br>         }<br>         visited[i]=1;<br>         tmp.push_back(nums[i]);<br>         dfs(res,tmp,nums,i+1,visited);<br>         tmp.pop_back();<br>         visited[i]=0;<br>     }<br> }</nums.size();i++){></int></int></int></vector<int></int></int></vector<int></int></vector<int></p>
</blockquote>
<p>#####回文数_9</p>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: 121</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<p>解法：</p>
<blockquote>
<p>bool isPalindrome(int x) {<br>        if(x<0){ return="" false;="" }="" list<int="">tmp;<br>        while(x&gt;0){<br>            tmp.push_back(x%10);<br>            x=x/10;<br>        }<br>        while(tmp.size()&gt;1){<br>            int top=tmp.front();<br>            tmp.pop_front();<br>            int back=tmp.back();<br>            tmp.pop_back();<br>            if(top!=back){<br>                return false;<br>            }<br>        }<br>        return true;<br>    }</0){></p>
</blockquote>
<p>#####在排序数组中查找元素的第一个和最后一个位置_34</p>
<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>解法：先用二分查找找出位置，再分别向前向后查找</p>
<blockquote>
<p>vector<int> searchRange(vector<int>&amp; nums, int target) {<br>        vector<int>res;<br>        int pos=midSearch(nums,target,0,nums.size()-1);<br>        if(pos==-1){<br>            res.push_back(-1);<br>            res.push_back(-1);<br>            return res;<br>        }<br>        int left=pos,right=pos;<br>        while(left&gt;=0 &amp;&amp; nums[left]==target){<br>            left–;<br>        }<br>        while(right<nums.size() &&="" nums[right]="=target){" right++;="" }="" left++;="" right--;="" res.push_back(left);="" res.push_back(right);="" return="" res;="" int="" midsearch(vector<int="">&amp;nums,int target,int start,int end){<br>        if(start&gt;end){<br>            return -1;<br>        }<br>        int mid=start+(end-start)/2;<br>        if(nums[mid]==target){<br>            return mid;<br>        }else if(nums[mid]&lt;target){<br>            return midSearch(nums,target,mid+1,end);<br>        }else{<br>            return midSearch(nums,target,start,mid-1);<br>        }</nums.size()></int></int></int></p>
<p>}</p>
</blockquote>
<p>#####最大子序和_53</p>
<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p>
<p>解法：用动态规划</p>
<blockquote>
<p>int maxSubArray(vector<int>&amp; nums) {<br>       int dp[nums.size()];<br>        dp[0]=nums[0];<br>        int res=nums[0];<br>        for(int i=1;i&lt;nums.size();i++){<br>            dp[i]=max(nums[i],dp[i-1]+nums[i]);<br>            res=max(res,dp[i]);<br>        }<br>        return res;<br>    }</int></p>
</blockquote>
<p>#####爬楼梯_70</p>
<p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>解法：用动态规划</p>
<blockquote>
<p>int climbStairs(int n) {<br>        //第一步爬1阶(f(n-1)) or 第一步爬2阶(f(n-2))<br>        int map[n+1];<br>        map[1]=1;<br>        if(n&gt;=2){<br>            map[2]=2;<br>        }<br>        if(n&lt;=2){<br>            return map[n];<br>        }<br>        for(int i=3;i&lt;=n;i++){<br>            map[i]=map[i-2]+map[i-1];<br>        }<br>        return map[n];<br>    }</p>
</blockquote>
<p>#####最小路径和_64</p>
<p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>解法：用动态规划，而不是深搜</p>
<blockquote>
<p>int minPathSum(vector<vector<int>&gt;&amp; grid) {<br>        //int res=INT_MAX;<br>        //dfs(grid,0,0,grid[0][0],&amp;res);<br>        //return res;<br>          int m = grid.size(), n = grid[0].size();<br>        int dp[m][n];<br>        dp[0][0] = grid[0][0];<br>        for (int i = 1; i &lt; m; ++i) dp[i][0] = grid[i][0] + dp[i - 1][0];<br>        for (int i = 1; i &lt; n; ++i) dp[0][i] = grid[0][i] + dp[0][i - 1];<br>        for (int i = 1; i &lt; m; ++i) {<br>            for (int j = 1; j &lt; n; ++j) {<br>                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);<br>            }<br>        }<br>        return dp[m - 1][n - 1];<br>    }<br>    /<em><br>    void dfs(vector<vector<int>&gt;&amp; grid,int x,int y,int len,int </vector<int></em>res){<br>        if(x==grid.size()-1 &amp;&amp; y==grid[0].size()-1){<br>            if(len&lt;<em>res){
               </em>res=len;<br>            }<br>            return;<br>        }<br>        if(x&lt;grid.size()-1){<br>            dfs(grid,x+1,y,len+grid[x+1][y],res);<br>        }<br>         if(y&lt;grid[0].size()-1){<br>            dfs(grid,x,y+1,len+grid[x][y+1],res);<br>        }<br>    }<br>    */</vector<int></p>
</blockquote>
<p>#####反转链表II_92</p>
<p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转</p>
<p>解法：指针的操作，记得设一个指针指向头指针，防止反转的起点头指针</p>
<blockquote>
<p>ListNode<em> reverseBetween(ListNode</em> head, int m, int n) {<br>        //用快慢指针<br>       ListNode <em>dummy=new ListNode(-1),</em>pre=dummy;<br>        pre-&gt;next=head;<br>        for(int i=0;i<m-1;i++){ pre="pre-">next;</m-1;i++){></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    &#125;</div><div class="line">   ListNode *cur=pre-&gt;next;</div><div class="line">    for(int i=m;i&lt;n;i++)&#123;</div><div class="line">        ListNode *t=cur-&gt;next;</div><div class="line">        cur-&gt;next=t-&gt;next;</div><div class="line">        t-&gt;next=pre-&gt;next;</div><div class="line">        pre-&gt;next=t;</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">    return dummy-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####不同路径II(三星研究院的题目，当时用的是深搜)_63</p>
<p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>解法：</p>
<p>用动态规划，dp[i][j] = dp[i-1][j] + dp[i][j-1]</p>
<blockquote>
<p>int uniquePathsWithObstacles(vector<vector<int>&gt;&amp; obstacleGrid) {<br>        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) return 0;<br>        int m = obstacleGrid.size(), n = obstacleGrid[0].size();<br>        vector<vector<long>&gt; dp(m + 1, vector<long>(n + 1, 0));<br>        dp[0][1] = 1;<br>        for (int i = 1; i &lt;= m; ++i) {<br>            for (int j = 1; j &lt;= n; ++j) {<br>                if (obstacleGrid[i - 1][j - 1] != 0) continue;<br>                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];<br>            }<br>        }<br>        return dp[m][n];<br>    }</long></vector<long></vector<int></p>
</blockquote>
<p>#####合并区间_56</p>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<blockquote>
<p> vector<interval> merge(vector<interval>&amp; intervals) {<br>        if (intervals.empty()) return {};<br>        sort(intervals.begin(), intervals.end(), <a href="Interval &amp;a, Interval &amp;b"></a> {return a.start &lt; b.start;});<br>        vector<interval> res{intervals[0]};<br>        for (int i = 1; i &lt; intervals.size(); ++i) {<br>            if (res.back().end &lt; intervals[i].start) {<br>                res.push_back(intervals[i]);<br>            } else {<br>                res.back().end = max(res.back().end, intervals[i].end);<br>            }<br>        }<br>        return res;<br>    }</interval></interval></interval></p>
</blockquote>
<p>#####删除排序数组中的重复项||_80</p>
<p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>解法：做一个标记(flag)，记录那些出现过但是次数没有达到2次的元素</p>
<blockquote>
<p>int removeDuplicates(vector<int>&amp; nums) {<br>        if(nums.size()&lt;2){<br>            return nums.size();<br>        }<br>        int tmp=nums[0];<br>        int  flag=0;//标记<br>        for(int i=1;i&lt;nums.size();i++){<br>            if(nums[i]==tmp){//相等的时候<br>                if(flag==0){<br>                    flag=1;<br>                }else{<br>                    nums.erase(nums.begin()+i);<br>                    i–;<br>                }<br>            }else{<br>                tmp=nums[i];<br>                flag=0;<br>            }</int></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    &#125;</div><div class="line">    return nums.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####对称二叉树_101</p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>解法：递归判断 root-&gt;left-&gt;left和root-&gt;right-&gt;right对应</p>
<blockquote>
<p>bool isSymmetric(TreeNode<em> root) {<br>     if (!root) return true;<br>        return isSymmetric(root-&gt;left, root-&gt;right);<br>    }<br>bool isSymmetric(TreeNode </em>left, TreeNode *right) {<br>        if (!left &amp;&amp; !right) return true;<br>        if (left &amp;&amp; !right || !left &amp;&amp; right || left-&gt;val != right-&gt;val) return false;<br>        return isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;left);<br>    }</p>
</blockquote>
<p>#####只出现一次的数字II_137</p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>解法：建立一个32位的数字(int型)，来统计每一位上1出现的个数。如果某一位上为1的话，那么如果该整数出现了3次，对3去余则为0，若出现4次则为1，我们把每个数的对应位都加起来对3取余，最终剩下来的那个数就是单独的数字</p>
<blockquote>
<p>int singleNumber(vector<int>&amp; nums) {<br>      int res = 0;<br>        for (int i = 0; i &lt; 32; ++i) {<br>            int sum = 0;<br>            for (int j = 0; j &lt; nums.size(); ++j) {<br>                sum += (nums[j] &gt;&gt; i) &amp; 1;<br>            }<br>            res |= (sum % 3) &lt;&lt; i;<br>        }<br>        return res;<br>    }</int></p>
</blockquote>
<p>#####乘积最大子序列_152</p>
<p>给定一个整数数组 <code>nums</code> (包含负数、0)，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
<p>解法：使用动态规划，因为很小的负数乘一个负数会成一个很大的正数，因此建立两个数组，一个记录连乘最小的数，一个记录连乘最大的数。</p>
<blockquote>
<p>//<a href="http://www.cnblogs.com/grandyang/p/4028713.html" target="_blank" rel="external">http://www.cnblogs.com/grandyang/p/4028713.html</a><br>    int maxProduct(vector<int>&amp; nums) {<br>        int n=nums.size();<br>        int res=nums[0];<br>        vector<int>dp_max(n,0),dp_min(n,0);<br>        dp_max[0]=res;<br>        dp_min[0]=res;<br>        for(int i=1;i&lt;nums.size();i++){<br>           dp_max[i]=max(nums[i],max(nums[i]<em>dp_max[i-1],nums[i]</em>dp_min[i-1]));<br>           dp_min[i]=min(nums[i],min(nums[i]<em>dp_max[i-1],nums[i]</em>dp_min[i-1]));<br>           res=max(res,dp_max[i]);<br>        }<br>        return res;<br>    }</int></int></p>
</blockquote>
<p>#####最大数_179</p>
<p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p>
<p>如：输入：[10,2]    输出：210</p>
<p>解法：将数字转换为字符串相加排序进行排序，序高者在前</p>
<blockquote>
<p>static bool cmp(int a,int b){<br>        return to_string(a) + to_string(b) &gt; to_string(b) + to_string(a);<br>    }<br>    string largestNumber(vector<int>&amp; nums) {<br>        sort(nums.begin(),nums.end(),cmp);<br>        string res=””;<br>        for(int i=0;i&lt;nums.size();i++){<br>            res+=to_string(nums[i]);<br>        }<br>        return res;</int></p>
</blockquote>
<p>#####岛屿的个数_200</p>
<p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入:</div><div class="line">11110</div><div class="line">11010</div><div class="line">11000</div><div class="line">00000</div><div class="line"></div><div class="line">输出: 1</div></pre></td></tr></table></figure>
<p>解法：使用深搜，记住不是动态规划</p>
<blockquote>
<p>int numIslands(vector<vector<char>&gt;&amp; grid) {<br>          if (grid.empty() || grid[0].empty()) return 0;<br>        int m=grid.size(),n=grid[0].size();<br>        int res=0;<br>       vector<vector<int>&gt;visited(m,vector<int>(n,0));<br>        for(int i=0;i<m;i++){ for(int="" j="0;j<n;j++){" if(grid[i][j]="='1'" &&="" visited[i][j]="=0){" dfs(grid,i,j,visited);="" res++;="" }="" return="" res;="" void="" dfs(vector<vector<char="">&gt;&amp; grid,int x,int y,vector<vector<int>&gt;&amp;visited){<br>        if(x&gt;=grid.size()||y&gt;=grid[0].size()||x&lt;0||y&lt;0){<br>            return ;<br>        }<br>        if(grid[x][y]==’0’||visited[x][y]==1){//不通或者已访问过<br>            return;<br>        }<br>        visited[x][y]=1;<br>        dfs(grid,x+1,y,visited);<br>        dfs(grid,x,y+1,visited);<br>        dfs(grid,x,y-1,visited);<br>        dfs(grid,x-1,y,visited);<br>    }</vector<int></m;i++){></int></vector<int></vector<char></p>
</blockquote>
<p>#####重建二叉树</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>解法：</p>
<blockquote>
<p>TreeNode<em> reConstructBinaryTree(vector<int> pre,vector<int> vin) {<br>           TreeNode </int></int></em>root=reConstructBinaryTree(pre,0,pre.size()-1,vin,0,vin.size()-1);<br>            return root;<br>    }<br>    TreeNode <em> reConstructBinaryTree(vector<int> pre,int start_pre,int end_pre,vector<int> vin,int start_vin,int end_vin){<br>        if(start_pre&gt;end_pre || start_vin&gt;end_vin){<br>            return NULL;<br>        }<br>        TreeNode </int></int></em>root=new TreeNode(pre[start_pre]);<br>        for(int i=start_vin;i&lt;=end_vin;i++)<br>            if(vin[i]==pre[start_pre]){<br>                root-&gt;left=reConstructBinaryTree(pre,start_pre+1,start_pre+i-start_vin,vin,start_vin,i-1);<br>                root-&gt;right=reConstructBinaryTree(pre,i-start_vin+start_pre+1,end_pre,vin,i+1,end_vin);<br>                break;</p>
<p>​    }</p>
<p>return root;<br>}</p>
</blockquote>
<p>#####用两个栈实现队列的功能(先进先出)</p>
<p>解法：</p>
<p>入队：将元素进栈A</p>
<p>出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；</p>
<p>如果不为空，栈B直接出栈。</p>
<blockquote>
<p> void push(int node) {<br>          stack1.push(node);<br>     }</p>
</blockquote>
<pre><code>int pop() {
      int a;
    if(stack2.empty()){
        while(!stack1.empty()){
            a=stack1.top();
            stack2.push(a);
            stack1.pop();
        }
    }
    a=stack2.top();
    stack2.pop();
    return a;
}
</code></pre><p>private:<br>    stack<int> stack1;<br>    stack<int> stack2;</int></int></p>
<p>#####矩形覆盖</p>
<p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p>解法：用动态规划，f(n)=f(n-1)+f(n-2)</p>
<blockquote>
<p> int rectCover(int number) {<br>         if(number==0){<br>             return 0;<br>         }<br>         if(number  == 1){<br>             return 1;<br>         }<br>         if(number<em>2 == 2){<br>             return 1;<br>         }else if(number</em>2 == 4){<br>             return 2;<br>         }else{<br>             return rectCover((number-1))+rectCover(number-2);<br>         }<br>     }</p>
</blockquote>
<p>#####二进制中1的个数</p>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">-------------可能陷入死循环的解法---------------------</div><div class="line">//可能陷入死循环的方法是因为&gt;&gt;右移是带符号位右移的导致，右移空出来的位子都是1所以进入死循环。如果把n=n&gt;&gt;1改成n=n&gt;&gt;&gt;1就不会进入死循环了。&gt;&gt;&gt;是无视符号的右移</div><div class="line">    /*public static int NumberOf1_CanNotUse(int n) &#123;</div><div class="line">        int count = 0;</div><div class="line">        while (n != 0) &#123;</div><div class="line">            /*</div><div class="line">            * 用1和n进行位与运算，</div><div class="line">            * 结果要是为1则n的2进制形式</div><div class="line">            * 最右边那位肯定是1，否则为0</div><div class="line">            */</div><div class="line">            if((n &amp; 1) == 1) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            //把n的2进制形式往右推一位</div><div class="line">            n = n &gt;&gt; 1;</div><div class="line">        &#125;</div><div class="line">        return count;</div><div class="line">    &#125;*/</div><div class="line">    //---------------正解--------------------------------</div><div class="line">    //思想：用1（1自身左移运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数</div><div class="line">    private static int NumberOf1_low( int n) &#123;</div><div class="line">        int count = 0;</div><div class="line">        int flag = 1;</div><div class="line">        while (flag != 0) &#123;</div><div class="line">            if ((n &amp; flag) != 0) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            flag = flag &lt;&lt; 1;</div><div class="line">        &#125;</div><div class="line">        return` `count;</div><div class="line">    &#125;</div><div class="line">    //--------------------最优解----------------------------</div><div class="line">    public static int NumberOf1(int n) &#123;</div><div class="line">        int count = 0;</div><div class="line">        while (n != 0) &#123;</div><div class="line">            ++count;</div><div class="line">            n = (n - 1) &amp; n;</div><div class="line">        &#125;</div><div class="line">        return count;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>#####调整数组顺序使奇数位于偶数的前面</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>解法：从左向右遍历，若遇到偶数，则从数组中删除，并将其加到数组末尾</p>
<blockquote>
<p>void reOrderArray(vector<int> &amp;array) {<br>      int n=array.size(),i=0;<br>      while(i&lt;n){<br>          if(array[i]%2==0){<br>              int tmp=array[i];<br>              array.erase(array.begin()+i);<br>              array.push_back(tmp);<br>              n–;<br>              i–;<br>          }<br>            i++;<br>      }<br>   }</int></p>
</blockquote>
<p>#####链表中倒数第k个结点</p>
<p>解法：可使用快慢指针，快指针先走k个节点，然后两个节点一起走，当快节点到达末尾时，满节点就到达了倒数第k个节点</p>
<h5 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h5><p> ListNode<em> ReverseList(ListNode</em> pHead) {<br>        if(pHead==NULL || pHead-&gt;next==NULL){<br>            return pHead;<br>        }      </p>
<pre><code>    ListNode *cur=pHead,*curNext=pHead-&gt;next;
    cur-&gt;next=NULL;
    while(curNext){
       ListNode *tmp=curNext;
        curNext=curNext-&gt;next;
        tmp-&gt;next=cur;
        cur=tmp;
    }
    return cur;
}
</code></pre><h5 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h5><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">bool isSubtree(TreeNode* pRootA, TreeNode* pRootB) &#123;</div><div class="line">        if (pRootB == NULL) return true;</div><div class="line">        if (pRootA == NULL) return false;</div><div class="line">        if (pRootB-&gt;val == pRootA-&gt;val) &#123;</div><div class="line">            return isSubtree(pRootA-&gt;left, pRootB-&gt;left)</div><div class="line">                &amp;&amp; isSubtree(pRootA-&gt;right, pRootB-&gt;right);</div><div class="line">        &#125; else return false;</div><div class="line">    &#125;</div><div class="line">bool HasSubtree(TreeNode* pRootA, TreeNode* pRootB)</div><div class="line">    &#123;</div><div class="line">        if (pRootA == NULL || pRootB == NULL) return false;</div><div class="line">        	return isSubtree(pRootA, pRootB) ||</div><div class="line">            HasSubtree(pRootA-&gt;left, pRootB) ||</div><div class="line">            HasSubtree(pRootA-&gt;right, pRootB);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h5><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>解法：顺序遍历压入序列，将其压入栈，当栈顶元素和弹出序列头部相等时，栈弹出。最终若栈为空，则返回true</p>
<blockquote>
<p> bool IsPopOrder(vector<int> pushV,vector<int> popV) {<br>         stack<int>st;<br>         int t=0;<br>         for(int i=0;i&lt;pushV.size();i++){<br>             st.push(pushV[i]);<br>             while(t&lt;popV.size()  &amp;&amp; st.top()==popV[t]){<br>                 st.pop();<br>                 t++;<br>             }<br>         }<br>         if(st.size()==0){<br>             return true;<br>         }else{<br>             return false;<br>         }<br>     }</int></int></int></p>
</blockquote>
<h5 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h5><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<p>解法：使用深搜</p>
<blockquote>
<p>vector<vector<int> &gt;allRes;<br>    vector<int> tmp;<br>    void dfsFind(TreeNode <em> node , int left){<br>        tmp.push_back(node-&gt;val);<br>        if(left-node-&gt;val == 0 &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right)<br>            allRes.push_back(tmp);<br>        else {<br>            if(node-&gt;left) dfsFind(node-&gt;left, left-node-&gt;val);<br>            if(node-&gt;right) dfsFind(node-&gt;right, left-node-&gt;val);<br>        }<br>        tmp.pop_back();<br>    }<br>    vector<vector<int> &gt; FindPath(TreeNode</vector<int></em> root,int expectNumber) {<br>         if(root) dfsFind(root, expectNumber);<br>        return allRes;<br>    }</int></vector<int></p>
</blockquote>
<h5 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h5><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>解法：递归</p>
<blockquote>
<p>bool isSymmetrical(TreeNode<em> pRoot)<br>    {<br>        if(pRoot == NULL){<br>                return true;<br>            }<br>            return comRoot(pRoot-&gt;left, pRoot-&gt;right);<br>      }<br>      bool comRoot(TreeNode </em>left, TreeNode *right) {<br>            // TODO Auto-generated method stub<br>            if(left == NULL) return right==NULL;<br>            if(right == NULL) return false;<br>            if(left-&gt;val != right-&gt;val) return false;<br>            return comRoot(left-&gt;right,right-&gt;left) &amp;&amp; comRoot(left-&gt;left,right-&gt;right);<br>        }</p>
</blockquote>
<h5 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h5><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>解法：使用深搜，用visited数组记录是否访问过</p>
<blockquote>
<p> int movingCount(int threshold, int rows, int cols)<br>   {<br>      int visited[rows<em>cols];<br>       memset(visited, 0, sizeof(visited));<br>       return dfs(threshold,1,1,rows,cols,visited);<br>   }<br> int func(int n){<br>       int res=0;<br>       while(n&gt;0){<br>           res+=n%10;<br>           n=n/10;<br>       }<br>       return res;<br>   }<br>   int dfs(int threshold,int x,int y,int row,int col,int visited[]){<br>       cout&lt;&lt;”heihei x=”&lt;<x<<"y="<<y<<endl; 因为是从(0,0开始的，所以要func(x-1)="" func(y-1)="" if(x<1="" ||="" y<1="" x="">row || y&gt;col || visited[(x-1)</x<<"y="<<y<<endl;></em>col+(y-1)]==1 || func(x-1)+func(y-1)&gt;threshold){<br>           return 0;<br>       }<br>       cout&lt;&lt;”x:”&lt;&lt;x&lt;&lt;”y”&lt;&lt;y&lt;&lt;endl;<br>       visited[(x-1)*col+(y-1)]=1;<br>       return dfs(threshold,x,y+1,row,col,visited)+<br>       dfs(threshold,x,y-1,row,col,visited)+<br>       dfs(threshold,x-1,y,row,col,visited)+<br>       dfs(threshold,x+1,y,row,col,visited)+1;<br>   }</p>
</blockquote>
<h5 id="最大正方形-221"><a href="#最大正方形-221" class="headerlink" title="最大正方形_221"></a>最大正方形_221</h5><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">输入: </div><div class="line"></div><div class="line">1 0 1 0 0</div><div class="line">1 0 1 1 1</div><div class="line">1 1 1 1 1</div><div class="line">1 0 0 1 0</div><div class="line"></div><div class="line">输出: 4</div></pre></td></tr></table></figure>
<p>解法：使用动态规划，注意递归式为：dp[i][j]=min(dp[i][j-1],dp[i-1][j-1],dp[i-1][j])</p>
<p>而不是dp[i][j]=dp[i-1][j–1]+1</p>
<blockquote>
<p>int maximalSquare(vector<vector<char>&gt;&amp; matrix) {<br>     if(matrix.empty() || matrix[0].empty()){<br>         return 0;<br>     }<br>     int m=matrix.size(),n=matrix[0].size();<br>     vector<vector<int>&gt;mp(m,vector<int>(n,0));<br>     int res=0;<br>     for(int i=0;i&lt;m;i++){<br>         if(matrix[i][0]==’1’){<br>             mp[i][0]=1;<br>             res=1;<br>         }<br>     }<br>      for(int i=0;i&lt;n;i++){<br>         if(matrix[0][i]==’1’){<br>             mp[0][i]=1;<br>             res=1;<br>         }<br>     }<br>     for(int i=1;i&lt;m;i++){<br>         for(int j=1;j&lt;n;j++){<br>             if(matrix[i][j]==’1’){<br>             //if(matrix[i][j]==’1’ &amp;&amp; matrix[i-1][j]==’1’ &amp;&amp; matrix[i][j-1]==’1’ &amp;&amp; matrix[i-1][j-1]==’1’){<br>                // mp[i][j]=mp[i-1][j-1]+1;<br>                 mp[i][j]=min(mp[i-1][j-1],(min(mp[i-1][j],mp[i][j-1])))+1;<br>                 res=max(res,mp[i][j]);<br>             }<br>         }<br>     }<br>     return res*res;<br> }</int></vector<int></vector<char></p>
</blockquote>
<h5 id="反转链表-206"><a href="#反转链表-206" class="headerlink" title="反转链表_206"></a>反转链表_206</h5><blockquote>
<p>ListNode<em> reverseList(ListNode</em> head) {<br>        ListNode <em>newHead=NULL;<br>        while(head){<br>            ListNode </em>node=head-&gt;next;<br>            head-&gt;next=newHead;<br>            newHead=head;<br>            head=node;<br>        }<br>        return newHead;<br>    }</p>
</blockquote>
<h5 id="构造回文"><a href="#构造回文" class="headerlink" title="构造回文"></a>构造回文</h5><p>给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？输出需要删除的字符个数。</p>
<p>解法：求原字符串和其反串的最大公共子串的长度，然后用原字符串的长度减去这个最大公共子串的长度就得到了最小编辑长度。或者求其所有子字符串，然后判断是否为回文？(应该会超时)</p>
<blockquote>
<p>#include<iostream></iostream></p>
<p>#include<string></string></p>
<p>#include<algorithm></algorithm></p>
<p>using namespace std;</p>
<p>const int MAX = 1001;<br>int MaxLen[MAX][MAX]; //最长公共子序列，动态规划求法</p>
<p>int maxLen(string s1, string s2){<br>    int length1 = s1.size();<br>    int length2 = s2.size();<br>    for (int i = 0; i &lt;= length1; ++i)<br>        MaxLen[i][0] = 0;<br>    for (int i = 0; i &lt;= length2; ++i)<br>        MaxLen[0][i] = 0;</p>
</blockquote>
<pre><code>for (int i = 1; i &lt;= length1; ++i)
{
    for (int j = 1; j &lt;= length2; ++j)
    {
        if (s1[i-1] == s2[j-1]){
            MaxLen[i][j] = MaxLen[i-1][j - 1] + 1;
        }
        else
        {
            MaxLen[i][j] = max(MaxLen[i - 1][j], MaxLen[i][j - 1]);
        }
    }
}

return MaxLen[length1][length2]
</code></pre><p>}</p>
<blockquote>
<p>int main(){<br>    string s;<br>    while (cin &gt;&gt; s){<br>        int length = s.size();<br>        if (length == 1){<br>            cout &lt;&lt; 1 &lt;&lt; endl;<br>            continue;<br>        }<br>        //利用回文串的特点<br>        string s2 = s;<br>        reverse(s2.begin(),s2.end());<br>        int max_length = maxLen(s, s2);<br>        cout &lt;&lt; length - max_length &lt;&lt; endl;<br>    }<br>    return 0;</p>
<p>}</p>
</blockquote>
<p>#####单词拆分_139</p>
<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p><strong>说明：</strong></p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</div><div class="line">输出: true</div><div class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</div></pre></td></tr></table></figure>
<p>解法：使用动态规划，dp[i]表示字符串的0到i位置可以被拆分</p>
<blockquote>
<p> bool wordBreak(string s, vector<string>&amp; wordDict) {<br>         unordered_set<string> wordSet(wordDict.begin(), wordDict.end());<br>         vector<bool> dp(s.size() + 1);<br>         dp[0] = true;<br>         for (int i = 0; i &lt; dp.size(); ++i) {<br>             for (int j = 0; j &lt; i; ++j) {<br>                 if (dp[j] &amp;&amp; wordSet.count(s.substr(j, i - j))) {<br>                     dp[i] = true;<br>                     break;<br>                 }<br>             }<br>         }<br>         return dp.back();<br>     }</bool></string></string></p>
</blockquote>
<p>#####二叉树的锯齿层次遍历_103</p>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  3</div><div class="line"> / \</div><div class="line">9  20</div><div class="line">  /  \</div><div class="line"> 15   7</div></pre></td></tr></table></figure>
<p>返回锯齿形层次遍历如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [20,9],</div><div class="line">  [15,7]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>解法：使用两个栈，一个栈是先进左子树再进右子树，另一个栈是先进右子树再进左子树</p>
<blockquote>
<p>vector<vector<int>&gt; zigzagLevelOrder(TreeNode<em> root) {<br>         vector<vector<int> &gt;res;<br>        if (!root) return res;<br>        stack&lt;TreeNode</vector<int></em>&gt; s1;<br>        stack<treenode*> s2;<br>        s1.push(root);<br>        vector<int> out;<br>        while (!s1.empty() || !s2.empty()) {<br>            while (!s1.empty()) {<br>                TreeNode <em>cur = s1.top();<br>                s1.pop();<br>                out.push_back(cur-&gt;val);<br>                if (cur-&gt;left) s2.push(cur-&gt;left);<br>                if (cur-&gt;right) s2.push(cur-&gt;right);<br>            }<br>            if (!out.empty()) res.push_back(out);<br>            out.clear();<br>            while (!s2.empty()) {<br>                TreeNode </em>cur = s2.top();<br>                s2.pop();<br>                out.push_back(cur-&gt;val);<br>                if (cur-&gt;right) s1.push(cur-&gt;right);<br>                if (cur-&gt;left) s1.push(cur-&gt;left);<br>            }<br>            if (!out.empty()) res.push_back(out);<br>            out.clear();<br>        }<br>        return res;<br>    }</int></treenode*></vector<int></p>
</blockquote>
<p>#####单词接龙_127</p>
<p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li><p>每次转换只能改变一个字母。</p>
</li>
<li><p>转换过程中的中间单词必须是字典中的单词。</p>
<p>解法：使用光谱搜索，层次遍历，最后返回最短层深度(深搜应该也行，但是可能会超时)</p>
<blockquote>
<p>int ladderLength(string beginWord, string endWord, vector<string>&amp; wordList) {</string></p>
<pre><code>unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end());
if (!wordSet.count(endWord)) return 0;
queue&lt;string&gt; q{{beginWord}};
int res = 0;
while (!q.empty()) {
    for (int k = q.size(); k &gt; 0; --k) {
        string word = q.front(); q.pop();
        if (word == endWord) return res + 1;
        for (int i = 0; i &lt; word.size(); ++i) {
            string newWord = word;
            for (char ch = &apos;a&apos;; ch &lt;= &apos;z&apos;; ++ch) {
                newWord[i] = ch;
                if (wordSet.count(newWord) &amp;&amp; newWord != word) {
                    q.push(newWord);
                    wordSet.erase(newWord);
                }   
            }
        }
    }
    ++res;
}
return 0;
</code></pre><p>   }</p>
</blockquote>
</li>
</ol>
<h5 id="求根到叶子节点数字之和-129"><a href="#求根到叶子节点数字之和-129" class="headerlink" title="求根到叶子节点数字之和_129"></a>求根到叶子节点数字之和_129</h5><p>给定一个二叉树，它的每个结点都存放一个 <code>0-9</code> 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 <code>1-&gt;2-&gt;3</code> 代表数字 <code>123</code>。计算从根到叶子节点生成的所有数字之和。</p>
<p>解法：使用广搜，新节点加入时数字变为 父节点值*10+子节点值</p>
<blockquote>
<p>int sumNumbers(TreeNode<em> root) {<br>       if(root==NULL){<br>           return 0;<br>       }<br>       queue&lt;TreeNode</em>&gt;qu;<br>       qu.push(root);<br>       int res=0;<br>       while(!qu.empty()){<br>           TreeNode <em>tmp=qu.front();qu.pop();<br>           if(tmp-&gt;left==NULL &amp;&amp; tmp-&gt;right==NULL){<br>               res+=tmp-&gt;val;<br>           }else{<br>               if(tmp-&gt;left){<br>                   tmp-&gt;left-&gt;val+=tmp-&gt;val</em>10;<br>                   qu.push(tmp-&gt;left);<br>               }<br>               if(tmp-&gt;right){<br>                   tmp-&gt;right-&gt;val+=tmp-&gt;val*10;<br>                   qu.push(tmp-&gt;right);<br>               }<br>           }<br>       }<br>       return res;<br>   }</p>
</blockquote>
<h5 id="被围绕的去余-130"><a href="#被围绕的去余-130" class="headerlink" title="被围绕的去余_130"></a>被围绕的去余_130</h5><p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p>
<p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">X X X X</div><div class="line">X O O X</div><div class="line">X X O X</div><div class="line">X O X X</div></pre></td></tr></table></figure>
<p>运行你的函数后，矩阵变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">X X X X</div><div class="line">X X X X</div><div class="line">X X X X</div><div class="line">X O X X</div></pre></td></tr></table></figure>
<p>解法：对边缘区域使用深搜，若为’O’则以此为根搜索所有的‘O’，然后变为’$’；之后再将剩下的‘O’变为’X’</p>
<blockquote>
<p>void solve(vector<vector<char>&gt;&amp; board) {<br>        for (int i = 0; i &lt; board.size(); ++i) {<br>           for (int j = 0; j &lt; board[i].size(); ++j) {<br>               if ((i == 0 || i == board.size() - 1 || j == 0 || j == board[i].size() - 1) &amp;&amp; board[i][j] == ‘O’)<br>                   solveDFS(board, i, j);<br>           }<br>       }<br>       for (int i = 0; i &lt; board.size(); ++i) {<br>           for (int j = 0; j &lt; board[i].size(); ++j) {<br>               if (board[i][j] == ‘O’) board[i][j] = ‘X’;<br>               if (board[i][j] == ‘\$’) board[i][j] = ‘O’;<br>           }<br>       }<br>   }<br>   void solveDFS(vector<vector<char> &gt; &amp;board, int i, int j) {<br>       if (board[i][j] == ‘O’) {<br>           board[i][j] = ‘​$’;<br>           if (i &gt; 0 &amp;&amp; board[i - 1][j] == ‘O’)<br>               solveDFS(board, i - 1, j);<br>           if (j &lt; board[i].size() - 1 &amp;&amp; board[i][j + 1] == ‘O’)<br>               solveDFS(board, i, j + 1);<br>           if (i &lt; board.size() - 1 &amp;&amp; board[i + 1][j] == ‘O’)<br>               solveDFS(board, i + 1, j);<br>           if (j &gt; 1 &amp;&amp; board[i][j - 1] == ‘O’)<br>               solveDFS(board, i, j - 1);<br>       }<br>   } </vector<char></vector<char></p>
</blockquote>
<h5 id="反转字符串里的的单词-151"><a href="#反转字符串里的的单词-151" class="headerlink" title="反转字符串里的的单词_151"></a>反转字符串里的的单词_151</h5><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: &quot;  hello world!  &quot;</div><div class="line">输出: &quot;world! hello&quot;</div><div class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</div></pre></td></tr></table></figure>
<p>解法：storeIndex表示当前存储到的位置。先给整个字符串反转一下，然后我们开始循环，遇到空格直接跳过，如果是非空格字符，我们此时看storeIndex是否为0，为0的话表示第一个单词，不用增加空格；如果不为0，说明不是第一个单词，需要在单词中间加一个空格，然后我们要找到下一个单词的结束位置我们用一个while循环来找下一个为空格的位置，在此过程中继续覆盖原字符串，找到结束位置了，下面就来翻转这个单词，然后更新i为结尾位置，最后遍历结束，我们剪裁原字符串到storeIndex位置，就可以得到我们需要的结果</p>
<blockquote>
<p>string reverseWords(string s) {<br>          int storeIndex=0,len=s.size();<br>        reverse(s.begin(),s.end());<br>        for(int i=0;i&lt;len;i++){<br>              if (s[i] != ‘ ‘) {<br>                if (storeIndex != 0) s[storeIndex++] = ‘ ‘;<br>                int j = i;<br>                while (j &lt; len &amp;&amp; s[j] != ‘ ‘) s[storeIndex++] = s[j++];<br>                reverse(s.begin() + storeIndex - (j - i), s.begin() + storeIndex);<br>                i = j;<br>            }<br>        }<br>        s.resize(storeIndex);<br>        return s;<br>    }</p>
</blockquote>
<h5 id="长度最小的子数组-209"><a href="#长度最小的子数组-209" class="headerlink" title="长度最小的子数组_209"></a>长度最小的子数组_209</h5><p>给定一个含有 <strong>n</strong> 个正整数的数组和一个正整数 <strong>s ，</strong>找出该数组中满足其和 <strong>≥ s</strong> 的长度最小的连续子数组<strong>。</strong>如果不存在符合条件的连续子数组，返回 0。</p>
<p><strong>示例:</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: s = 7, nums = [2,3,1,2,4,3]</div><div class="line">输出: 2</div><div class="line">解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</div></pre></td></tr></table></figure>
<p>解法：</p>
<blockquote>
<p>  int minSubArrayLen(int s, vector<int>&amp; nums) {<br>         int left=0,sum=0,res=INT_MAX;<br>          for(int i=0;i<nums.size();i++) {="" sum+="nums[i];" while(left<="i" &&="" sum="">=s){<br>                  res=min(res,i-left+1);<br>                  sum-=nums[left];<br>                  left++;<br>              }<br>          }<br>          return res==INT_MAX?0:res;<br>      }</nums.size();i++)></int></p>
</blockquote>
<p>#####寻找重复数_287</p>
<p>给定一个包含 <em>n</em> + 1 个整数的数组 <em>nums</em>，其数字都在 1 到 <em>n</em> 之间（包括 1 和 <em>n</em>），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: [1,3,4,2,2]</div><div class="line">输出: 2</div></pre></td></tr></table></figure>
<p>解法：考虑用二分搜索法了，我们在区间[1, n]中搜索，首先求出中点mid，然后遍历整个数组，统计所有小于等于mid的数的个数，如果个数小于等于mid，则说明重复值在[mid+1, n]之间，反之，重复值应在[1, mid-1]之间，然后依次类推，直到搜索完成，此时的low就是我们要求的重复值</p>
<blockquote>
<p> int findDuplicate(vector<int>&amp; nums) {<br>         int left=0,right=nums.size()-1;<br>         while(left&lt;right){<br>             int mid=(left+right)/2;<br>             int count=0;<br>             for(int num:nums){<br>                 if(num&lt;=mid){<br>                     count++;<br>                 }<br>             }<br>             if(count&lt;=mid){<br>                 left=mid+1;<br>             }else{<br>                 right=mid;<br>             }<br>         }<br>         return right;<br>     }</int></p>
</blockquote>
<h5 id="n个人n个座位，求不能坐在自己座位上种数"><a href="#n个人n个座位，求不能坐在自己座位上种数" class="headerlink" title="n个人n个座位，求不能坐在自己座位上种数"></a>n个人n个座位，求不能坐在自己座位上种数</h5><p>解法：如果一共有i个人，则第i个人的位置对于其他i-1个人都是合法的，则这i-1个人都可能坐在i的位置上。如果第i个人坐在坐他位置的人的位置上，则将这两个人与其他的i-2个人分开了，有f[i-2]种；如果第i个人不坐在坐他位置的人的位置上，则剩下i-1个人不能坐自己的位置，则有f[i-1]种。所以递推式为：f[i]=(i-1)*(f[i-1]+f[i-2])</p>
<blockquote>
<p>void main()<br>{<br>int t;<br>int n;<br>int i;<br>f[1] = 0;<br>f[2] = 1;<br>for(i = 3; i &lt;= 100; ++i)<br>{<br>   f[i] = (i - 1) * (f[i - 1] + f[i -2]);<br>   f[i] %= (__int64)(1e9+7);<br>}<br>scanf(“%d”, &amp;t);<br>while(t–)<br>{<br>   scanf(“%d”, &amp;n);<br>   printf(“%lld\n”, f[n]);<br>}<br>}</p>
</blockquote>
<h5 id="搜索二维矩阵II-240"><a href="#搜索二维矩阵II-240" class="headerlink" title="搜索二维矩阵II_240"></a>搜索二维矩阵II_240</h5><p>编写一个高效的算法来搜索 <em>m</em> x <em>n</em> 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例:</strong></p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1,   4,  7, 11, 15],</div><div class="line">  [2,   5,  8, 12, 19],</div><div class="line">  [3,   6,  9, 16, 22],</div><div class="line">  [10, 13, 14, 17, 24],</div><div class="line">  [18, 21, 23, 26, 30]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>解法：注释里的解法会超时；从左下角进行遍历，若target大于当前值，则向右走，小于则向上走</p>
<blockquote>
<p>bool searchMatrix(vector<vector<int>&gt;&amp; matrix, int target) {<br>        if (matrix.empty() || matrix[0].empty()) return false;<br>         if (target &lt; matrix[0][0] || target &gt; matrix.back().back()) return false;<br>        int x=matrix.size()-1,y=0;<br>        while(true){<br>            if(target&gt;matrix[x][y]){<br>                y++;<br>            }else if(target<matrix[x][y]){ x--;="" }else{="" return="" true;="" }="" if(x<0="" ||="" y="">=matrix[0].size()){<br>                return false;<br>            }<br>        }<br>    }<br>   /<em> bool searchMatrix(vector<vector<int>&gt;&amp; matrix, int target) {<br>       if (matrix.empty() || matrix[0].empty()) return false;<br>        for(int i =matrix.size()-1;i&gt;=0;i–){<br>            if(target&gt;=matrix[i][0]){<br>                bool res=midSearch(matrix[i],target);<br>                if(res==true){<br>                    return true;<br>                }<br>            }<br>        }<br>        return false;<br>    }<br>    bool midSearch(vector<int>num,int target){<br>        int left=0,right=num.size()-1;<br>        while(left&lt;=right){<br>            int mid=(left+right)/2;<br>            if(target==num[mid]){<br>                return true;<br>            }else{<br>                if(target&gt;num[mid]){<br>                    left=mid+1;<br>                }else{<br>                    right=mid-1;<br>                }<br>            }<br>        }<br>        return false;<br>    }</int></vector<int></em>/</matrix[x][y]){></vector<int></p>
</blockquote>
<h5 id="二叉搜索树中第k小的元素-230"><a href="#二叉搜索树中第k小的元素-230" class="headerlink" title="二叉搜索树中第k小的元素_230"></a>二叉搜索树中第k小的元素_230</h5><p>给定一个二叉搜索树，编写一个函数 <code>kthSmallest</code> 来查找其中第 <strong>k</strong> 个最小的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</div><div class="line">       5</div><div class="line">      / \</div><div class="line">     3   6</div><div class="line">    / \</div><div class="line">   2   4</div><div class="line">  /</div><div class="line"> 1</div><div class="line">输出: 3</div></pre></td></tr></table></figure>
<p>解法：使用中序遍历，其就是一个有序数组</p>
<blockquote>
<p>int kthSmallest(TreeNode<em> root, int k) {<br>      int count=0;<br>       stack&lt;TreeNode</em>&gt;st;<br>       TreeNode *p=root;<br>       while(p!=NULL || st.size()!=0){<br>           while(p!=NULL){<br>               st.push(p);<br>               p=p-&gt;left;<br>           }<br>           p=st.top();<br>           st.pop();<br>           ++count;<br>           if(count==k){<br>               return p-&gt;val;<br>           }<br>           p=p-&gt;right;</p>
<p>​    }</p>
<p>​    return 0;</p>
<p>}</p>
</blockquote>
<h5 id="累加数-306"><a href="#累加数-306" class="headerlink" title="累加数_306"></a>累加数_306</h5><p>累加数是一个字符串，组成它的数字可以形成累加序列。</p>
<p>一个有效的累加序列必须<strong>至少</strong>包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。</p>
<p>给定一个只包含数字 <code>&#39;0&#39;-&#39;9&#39;</code> 的字符串，编写一个算法来判断给定输入是否是累加数。</p>
<p>说明: 累加序列里的数不会以 0 开头，所以不会出现 <code>1, 2, 03</code> 或者 <code>1, 02, 3</code> 的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: &quot;199100199&quot;</div><div class="line">输出: true </div><div class="line">解释: 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199</div></pre></td></tr></table></figure>
<p>解法：</p>
<blockquote>
<p>bool isAdditiveNumber(string num) {<br>       for(int i=1;i<num.length();i++){ string="" s1="num.substr(0,i);" if(s1.size()="">1 &amp;&amp; s1[0]==’0’){<br>            break;<br>           }<br>           for(int j=i+1;j<num.length();j++){ string="" s2="num.substr(i,j-i);" long="" d1="stol(s1),d2=stol(s2);" if="" ((s2.size()=""> 1 &amp;&amp; s2[0] == ‘0’)) break;<br>               long next=d1+d2;<br>               string nextStr=to_string(next);<br>               if(nextStr!=num.substr(j,nextStr.length())){<br>                   continue;<br>               }<br>               string allStr=s1+s2+nextStr;<br>               while(allStr.size()&lt;num.size()){<br>                   d1=d2;<br>                   d2=next;<br>                   next=d1+d2;<br>                   nextStr=to_string(next);<br>                   allStr+=nextStr;<br>               }<br>               if(allStr==num){<br>                    return true;<br>               }<br>           }<br>       }<br>        return false;<br>    }</num.length();j++){></num.length();i++){></p>
</blockquote>
<h5 id="最小高度树-310"><a href="#最小高度树-310" class="headerlink" title="最小高度树_310"></a>最小高度树_310</h5><p>对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。</p>
<p>格式：该图包含 <code>n</code> 个节点，标记为 <code>0</code> 到 <code>n - 1</code>。给定数字 <code>n</code> 和一个无向边 <code>edges</code> 列表（每一个边都是一对标签）。</p>
<p>你可以假设没有重复的边会出现在 <code>edges</code> 中。由于所有的边都是无向边， <code>[0, 1]</code>和 <code>[1, 0]</code> 是相同的，因此不会同时出现在 <code>edges</code> 里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</div><div class="line"></div><div class="line">     0  1  2</div><div class="line">      \ | /</div><div class="line">        3</div><div class="line">        |</div><div class="line">        4</div><div class="line">        |</div><div class="line">        5 </div><div class="line"></div><div class="line">输出: [3, 4]</div></pre></td></tr></table></figure>
<blockquote>
<p>vector<int> findMinHeightTrees(int n, vector<pair<int, int="">&gt;&amp; edges) {<br>        if (n == 1) return {0};<br>        vector<int> res;<br>        vector<unordered_set<int>&gt; adj(n);<br>        queue<int> q;<br>        for (auto edge : edges) {<br>            adj[edge.first].insert(edge.second);<br>            adj[edge.second].insert(edge.first);<br>        }<br>        for (int i = 0; i &lt; n; ++i) {<br>            if (adj[i].size() == 1) q.push(i);<br>        }<br>        while (n &gt; 2) {<br>            int size = q.size();<br>            n -= size;<br>            for (int i = 0; i &lt; size; ++i) {<br>                int t = q.front(); q.pop();<br>                for (auto a : adj[t]) {<br>                    adj[a].erase(t);<br>                    if (adj[a].size() == 1) q.push(a);<br>                }<br>            }<br>        }<br>        while (!q.empty()) {<br>            res.push_back(q.front()); q.pop();<br>        }<br>        return res;<br>    }</int></unordered_set<int></int></pair<int,></int></p>
</blockquote>
<h5 id="完全平方数-279"><a href="#完全平方数-279" class="headerlink" title="完全平方数_279"></a>完全平方数_279</h5><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: n = 12</div><div class="line">输出: 3 </div><div class="line">解释: 12 = 4 + 4 + 4.</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: n = 13</div><div class="line">输出: 2</div><div class="line">解释: 13 = 4 + 9.</div></pre></td></tr></table></figure>
<p>解法：使用动态规划，dp[i]表示i的最小完全平方数，因此dp[i+j<em>j]=min(dp[i]+1,dp[i+j\</em>j])。深搜会超时</p>
<blockquote>
<p>int numSquares(int n) {<br>        vector<int>dp(n+1,INT_MAX);<br>        dp[0]=0;<br>        for(int i=0;i<n;i++){ for(int="" j="1;i+j*j<=n;j++){" dp[i+j*j]="min(dp[i+j*j],dp[i]+1);" }="" return="" dp[n];="" *="" int="" numsquares(int="" n)="" {="" res="n;" tmp="0;" dfs(n,tmp,&res);="" res;="" void="" dfs(int="" n,int="" tmp_len,int="" *res){="" if(n="=0){" if(tmp_len<*res){="" *res="tmp_len;" ;="" i="sqrt(n);i">=1;i–){<br>            dfs(n-i<em>i,tmp_len+1,res);<br>        }<br>    }</em>/</n;i++){></int></p>
</blockquote>
<h5 id="最大单词长度乘积-318"><a href="#最大单词长度乘积-318" class="headerlink" title="最大单词长度乘积_318"></a>最大单词长度乘积_318</h5><p>给定一个字符串数组 <code>words</code>，找到 <code>length(word[i]) * length(word[j])</code> 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]</div><div class="line">输出: 16 </div><div class="line">解释: 这两个单词为 &quot;abcw&quot;, &quot;xtfn&quot;。</div></pre></td></tr></table></figure>
<p>解法：使用mask的每一位来记录每个单词在26个英文字母上是否出现过</p>
<blockquote>
<p>int maxProduct(vector<string>&amp; words) {<br>        int res=0;<br>        vector<int>mask(words.size(),0);<br>        for(int i=0;i&lt;words.size();i++){<br>            for(char c:words[i]){<br>                mask[i]|=1&lt;&lt;(c-‘a’);<br>            }<br>            for(int j=0;j&lt;i;j++){<br>                if((mask[i]&amp;mask[j])==0){<br>                //   if(!(mask[i]&amp;mask[j])){<br>                       res=max(res,int(words[i].size()*words[j].size()));<br>                }<br>            }<br>        }<br>        return res;<br>    }</int></string></p>
</blockquote>
<h5 id="前K个高频元素-347"><a href="#前K个高频元素-347" class="headerlink" title="前K个高频元素_347"></a>前K个高频元素_347</h5><p>给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong> 高的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: nums = [1,1,1,2,2,3], k = 2</div><div class="line">输出: [1,2]</div></pre></td></tr></table></figure>
<p>解法：先使用map对元素进行计数，然后 放到一个vector里(map排序不会用)，再根据pair的value进行排序，最后取出前k个</p>
<blockquote>
<p>static bool cmp(const pair<int,int>&amp;m1,const pair<int,int>&amp;m2){<br>        return m1.second&gt;m2.second;<br>    }<br>    vector<int> topKFrequent(vector<int>&amp; nums, int k) {<br>        map<int,int>mp;<br>         vector<int>res;<br>        for(int i=0;i<nums.size();i++){ mp[nums[i]]++;="" *if(mp.count(nums[i])="=0){" mp[nums[i]]="1;" }else{="" }*="" }="" vector<pair<int,int="">&gt;vec;<br>       for(map<int,int>::iterator iter=mp.begin();iter!=mp.end();iter++){<br>            vec.push_back(make_pair(iter-&gt;first,iter-&gt;second));<br>        }<br>        /<em>for(vector<pair<int,int>&gt;::iterator iter=vec.begin();iter!=vec.end();iter++){<br>            vec.push_back(make_pair(iter-&gt;first,iter-&gt;second));<br>        }</pair<int,int></em>/<br>        sort(vec.begin(),vec.end(),cmp);</int,int></nums.size();i++){></int></int,int></int></int></int,int></int,int></p>
</blockquote>
<pre><code>    for(int i=0;i&lt;k;i++)
    {
        res.push_back(vec[i].first);
    }
    return res;
}
</code></pre><h5 id="零钱兑换-322"><a href="#零钱兑换-322" class="headerlink" title="零钱兑换_322"></a>零钱兑换_322</h5><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: coins = [1, 2, 5], amount = 11</div><div class="line">输出: 3 </div><div class="line">解释: 11 = 5 + 5 + 1</div></pre></td></tr></table></figure>
<p>解法：使用动态规划，dp[i]表示面值i所需的最少硬币个数</p>
<blockquote>
<p>int coinChange(vector<int>&amp; coins, int amount) {<br>        vector<int>dp(amount+1,INT_MAX);<br>        dp[0]=0;<br>        sort(coins.begin(),coins.end());<br>        for(int i=0;i&lt;=amount;i++){<br>            for(int j=0;j&lt;coins.size();j++){<br>                if(coins[j]&lt;=amount-i &amp;&amp; dp[i]!=INT_MAX){<br>                    dp[i+coins[j]]=min(dp[i+coins[j]],dp[i]+1);<br>                }<br>            }<br>        }<br>        if(dp[amount]==INT_MAX){<br>            return -1;<br>        }else{<br>            return dp[amount];<br>        }<br>    }</int></int></p>
</blockquote>
<h5 id="奇偶链表-328"><a href="#奇偶链表-328" class="headerlink" title="奇偶链表_328"></a>奇偶链表_328</h5><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</div><div class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</div></pre></td></tr></table></figure>
<p>解法：将原链表上奇数位置上和偶数位置上的数字重新排列，且原本的顺序不变，将pre指向奇数链的末尾，cur指向偶数链的末尾</p>
<blockquote>
<p>  ListNode<em> oddEvenList(ListNode</em> head) {<br>          if (!head || !head-&gt;next) return head;<br>        ListNode <em>pre=head,</em>cur=head-&gt;next;<br>         while(cur &amp;&amp; cur-&gt;next){<br>             ListNode *tmp=cur-&gt;next;<br>             cur-&gt;next=tmp-&gt;next;<br>             tmp-&gt;next=pre-&gt;next;<br>             pre-&gt;next=tmp;<br>             pre=pre-&gt;next;<br>              cur=cur-&gt;next;<br>         }<br>         return head;<br>     }</p>
</blockquote>
<h5 id="比特位计数-338"><a href="#比特位计数-338" class="headerlink" title="比特位计数_338"></a>比特位计数_338</h5><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: 2</div><div class="line">输出: [0,1,1]</div></pre></td></tr></table></figure>
<p>解法：从1开始，遇到偶数时，其1的个数和该偶数除以2得到的数字的1的个数相同，遇到奇数时，其1的个数等于该奇数除以2得到的数字的1的个数再加1</p>
<blockquote>
<p>vector<int> countBits(int num) {<br>        vector<int>res{0};<br>        for(int i=1;i&lt;=num;i++){<br>            if(i%2==0){//偶数<br>                res.push_back(res[i/2]);<br>            }else{<br>                res.push_back(res[i/2]+1);<br>            }<br>        }<br>        return res;<br>    }</int></int></p>
</blockquote>
<h5 id="整数拆分-343"><a href="#整数拆分-343" class="headerlink" title="整数拆分_343"></a>整数拆分_343</h5><p>给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: 10</div><div class="line">输出: 36</div><div class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</div></pre></td></tr></table></figure>
<p>解法：通过观察规律可知，我们可以看出从5开始，数字都需要先拆出所有的3，一直拆到剩下一个数为2或者4，因为剩4就不用再拆了，拆成两个2和不拆没有意义，而且4不能拆出一个3剩一个1，这样会比拆成2+2的乘积小</p>
<blockquote>
<p>int integerBreak(int n) {<br>         if (n == 2 || n == 3) return n - 1;<br>        int res=1;<br>        while(n&gt;4){<br>            res*=3;<br>            n-=3;<br>        }<br>        return res*n;<br>    }</p>
</blockquote>
<h5 id="查找和最小的K对数字-373"><a href="#查找和最小的K对数字-373" class="headerlink" title="查找和最小的K对数字_373"></a>查找和最小的K对数字_373</h5><p>给定两个以升序排列的整形数组 <strong>nums1</strong> 和 <strong>nums2</strong>, 以及一个整数 <strong>k</strong>。</p>
<p>定义一对值 <strong>(u,v)</strong>，其中第一个元素来自 <strong>nums1</strong>，第二个元素来自 <strong>nums2</strong>。</p>
<p>找到和最小的 k 对数字 <strong>(u1,v1), (u2,v2) … (uk,vk)</strong>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3</div><div class="line">输出: [1,2],[1,4],[1,6]</div><div class="line">解释: 返回序列中的前 3 对数：</div><div class="line">     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</div></pre></td></tr></table></figure>
<p>解法：遍历</p>
<blockquote>
<p>static bool cmp(pair<int,int>&amp;p1,pair<int,int>&amp;p2){<br>       return p1.first+p1.second<p2.first+p2.second; }="" vector<pair<int,="" int="">&gt; kSmallestPairs(vector<int>&amp; nums1, vector<int>&amp; nums2, int k) {<br>       vector<pair<int,int>&gt;res;<br>       for(int i=0;i<min((int)nums1.size(),k);i++){ for(int="" j="0;j<min((int)nums2.size(),k);j++){" res.push_back(make_pair(nums1[i],nums2[j]));="" }="" sort(res.begin(),res.end(),cmp);="" if(res.size()="">k){<br>           res.erase(res.begin()+k,res.end());<br>       }<br>       return res;<br>   }</min((int)nums1.size(),k);i++){></pair<int,int></int></int></p2.first+p2.second;></int,int></int,int></p>
</blockquote>
<h5 id="水壶问题-365"><a href="#水壶问题-365" class="headerlink" title="水壶问题_365"></a>水壶问题_365</h5><p>有两个容量分别为 <em>x</em>升 和 <em>y</em>升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <em>z</em>升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 <em>z升</em> 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: x = 3, y = 5, z = 4</div><div class="line">输出: True</div></pre></td></tr></table></figure>
<p>解法：参考：<a href="http://www.cnblogs.com/grandyang/p/5628836.html" target="_blank" rel="external">http://www.cnblogs.com/grandyang/p/5628836.html</a> 。问题转换成方程ax + by = d</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bool canMeasureWater(int x, int y, int z) &#123;</div><div class="line">       return z == 0 || (x + y &gt;= z &amp;&amp; z % gcd(x, y) == 0);</div><div class="line">   &#125;</div><div class="line">   int gcd(int x, int y) &#123;</div><div class="line">       return y == 0 ? x : gcd(y, x % y);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="最大整除子集-368"><a href="#最大整除子集-368" class="headerlink" title="最大整除子集_368"></a>最大整除子集_368</h5><p>给出一个由<strong>无重复的</strong>正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。</p>
<p>如果有多个目标子集，返回其中任何一个均可。</p>
<p> <strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: [1,2,3]</div><div class="line">输出: [1,2] (当然, [1,3] 也正确)</div></pre></td></tr></table></figure>
<p>解法：使用动态规划，dp[i]表示从i到末尾的最大整除子集的长度，注意要从尾到首遍历，同时用parent数组记录下一个被整除的数的下标，记住要从尾到首遍历，因为要记录整除集的第一个的下标</p>
<blockquote>
<p>vector<int> largestDivisibleSubset(vector<int>&amp; nums) {<br>        vector<int>dp(nums.size(),0);<br>        vector<int>parent(nums.size(),0);<br>        int count=0;<br>        int first_index;<br>        sort(nums.begin(),nums.end());<br>        for(int i=nums.size()-1;i&gt;=0;i–){<br>            for(int j=i;j<nums.size();j++){ if(nums[j]%nums[i]="=0" &&="" dp[i]<dp[j]+1){="" dp[i]="dp[j]+1;" parent[i]="j;" if(dp[i]="">count){<br>                        count=dp[i];<br>                        first_index=i;<br>                    }<br>                }<br>            }<br>        }<br>        vector<int>res;<br>        for(int i=0;i&lt;count;i++){<br>            res.push_back(nums[first_index]);<br>            first_index=parent[first_index];<br>        }<br>        return res;<br>    }</int></nums.size();j++){></int></int></int></int></p>
</blockquote>
<h5 id="灯泡开关-319"><a href="#灯泡开关-319" class="headerlink" title="灯泡开关_319"></a>灯泡开关_319</h5><p>初始时有 <em>n</em> 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 <em>i</em> 轮，每 <em>i</em> 个灯泡切换一次开关。 对于第 <em>n</em> 轮，你只切换最后一个灯泡的开关。 找出 <em>n</em> 轮后有多少个亮着的灯泡。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">输入: 3</div><div class="line">输出: 1 </div><div class="line">解释: </div><div class="line">初始时, 灯泡状态 [关闭, 关闭, 关闭].</div><div class="line">第一轮后, 灯泡状态 [开启, 开启, 开启].</div><div class="line">第二轮后, 灯泡状态 [开启, 关闭, 开启].</div><div class="line">第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </div><div class="line"></div><div class="line">你应该返回 1，因为只有一个灯泡还亮着。</div></pre></td></tr></table></figure>
<p>解法：参考<a href="http://www.cnblogs.com/grandyang/p/5100098.html" target="_blank" rel="external">http://www.cnblogs.com/grandyang/p/5100098.html</a> 只有小于n的平方数才会亮着，因为其余数的两次操作会使其开了再关掉</p>
<blockquote>
<p> int bulbSwitch(int n) {<br>         int res=0;<br>         for(int i=1;i*i&lt;=n;i++){<br>             res++;<br>         }<br>         return res;<br>     }</p>
</blockquote>
<h5 id="有序矩阵中的第K小的元素-378"><a href="#有序矩阵中的第K小的元素-378" class="headerlink" title="有序矩阵中的第K小的元素_378"></a>有序矩阵中的第K小的元素_378</h5><p>给定一个 <em>n x n</em> 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。<br>请注意，它是排序后的第k小元素，而不是第k个元素。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">matrix = [</div><div class="line">   [ 1,  5,  9],</div><div class="line">   [10, 11, 13],</div><div class="line">   [12, 13, 15]</div><div class="line">],</div><div class="line">k = 8,</div><div class="line"></div><div class="line">返回 13。</div></pre></td></tr></table></figure>
<p>解法：使用大顶堆，当堆中元素大于k时，去除堆顶元素，最终堆中剩余k个元素，堆首就是第k小的元素；也可以从矩阵的右下角开始进行层次遍历，因为每层都是递减的</p>
<p> int kthSmallest(vector<vector<int>&gt;&amp; matrix, int k) {<br>        priority_queue<int>q;<br>        for(int i=0;i<matrix.size();i++){ for(int="" j="0;j<matrix[0].size();j++){" q.push(matrix[i][j]);="" if(q.size()="">k){<br>                    q.pop();<br>                }<br>            }<br>        }<br>        return q.top();<br>    }<br>    /*<br>    int kthSmallest(vector<vector<int>&gt;&amp; matrix, int k) {<br>       queue<int>que;<br>        int m=matrix.size()-1,n=matrix[0].size()-1;<br>        int len=1;<br>        que.push(matrix[m][n]);<br>        while(!que.empty()){<br>            int size=que.size();<br>            if(k&lt;=size){<br>                sort(que.begin(),que.end());<br>                return que[size-k];<br>            }</int></vector<int></matrix.size();i++){></int></vector<int></p>
<p>​    }</p>
<p>}*/</p>
<h5 id="移掉K位数字-402"><a href="#移掉K位数字-402" class="headerlink" title="移掉K位数字_402"></a>移掉K位数字_402</h5><p>给定一个以字符串表示的非负整数 <em>num</em>，移除这个数中的 <em>k</em> 位数字，使得剩下的数字最小。</p>
<p><strong>注意:</strong></p>
<ul>
<li><em>num</em> 的长度小于 10002 且 ≥ <em>k。</em></li>
<li><em>num</em> 不会包含任何前导零。</li>
</ul>
<p><strong>示例 1 :</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: num = &quot;1432219&quot;, k = 3</div><div class="line">输出: &quot;1219&quot;</div><div class="line">解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</div></pre></td></tr></table></figure>
<p><strong>示例 2 :</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: num = &quot;10200&quot;, k = 1</div><div class="line">输出: &quot;200&quot;</div><div class="line">解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</div></pre></td></tr></table></figure>
<p>示例 <strong>3 :</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: num = &quot;10&quot;, k = 2</div><div class="line">输出: &quot;0&quot;</div><div class="line">解释: 从原数字移除所有的数字，剩余为空就是0。</div></pre></td></tr></table></figure>
<p>解法：如果n是num的长度，我们要去除k个，那么需要剩下n-k个，我们开始遍历给定数字num的每一位，对于当前遍历到的数字c，进行如下while循环，如果res不为空，且k大于0，且res的最后一位大于c，那么我们应该将res的最后一位移去，且k自减1。当跳出while循环后，我们将c加入res中，最后我们将res的大小重设为n-k。根据题目中的描述，可能会出现”0200”这样不符合要求的情况，所以我们用一个while循环来去掉前面的所有0，然后返回时判断是否为空，为空则返回“0”</p>
<blockquote>
<p> string removeKdigits(string num, int k) {<br>   string res=””;<br>     int keep=num.length()-k;<br>     for(char c:num){<br>         while(k&gt;0 &amp;&amp; res.size() &amp;&amp; res.back()&gt;c){<br>             res.pop_back();<br>             k–;<br>         }<br>         res.push_back(c);<br>     }<br>      res.resize(keep);<br>     while (!res.empty() &amp;&amp; res[0] == ‘0’) res.erase(res.begin());<br>     return res.empty() ? “0” : res;<br> }</p>
</blockquote>
<h5 id="活字印刷"><a href="#活字印刷" class="headerlink" title="活字印刷"></a>活字印刷</h5><p>你有一套活字字模 <code>tiles</code>，其中每个字模上都刻有一个字母 <code>tiles[i]</code>。返回你可以印出的非空字母序列的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入：&quot;AAB&quot;</div><div class="line">输出：8</div><div class="line">解释：可能的序列为 &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;。</div></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入：&quot;AAABBC&quot;</div><div class="line">输出：188</div></pre></td></tr></table></figure>
<p>解法：</p>
<blockquote>
<p>class Solution {<br>       int res=0;<br>       int[] visited;<br>   public int numTilePossibilities(String tiles) {<br>       if(tiles==null || tiles.length()==0){<br>           return 0;<br>       }<br>       char[] arrayCh=tiles.toCharArray();<br>       Arrays.sort(arrayCh);<br>       tiles=new String(arrayCh);</p>
<pre><code>visited=new int[tiles.length()];
for(int i=0;i&lt;visited.length;i++){
    visited[i]=0;
}
dfs(tiles,0);
return res;
</code></pre><p>   }<br>   public void dfs(String tiles,int cur){<br>       if(cur==tiles.length()){<br>           return;<br>       }<br>       for(int i=0;i<tiles.length();i++){ if(visited[i]="=1){" continue;="" }="" if(i="">0 &amp;&amp; tiles.charAt(i)==tiles.charAt(i-1) &amp;&amp; visited[i-1]==0){<br>               continue;<br>           }<br>           visited[i]=1;<br>           res++;<br>           dfs(tiles,cur+1);<br>           visited[i]=0;<br>       }<br>       return;<br>   }</tiles.length();i++){></p>
<p>}</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/13/Java中extend与implements的区别/" rel="next" title="Java中extend与implements的区别">
                <i class="fa fa-chevron-left"></i> Java中extend与implements的区别
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/28/Android知识点/" rel="prev" title="Android知识点">
                Android知识点 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/panpan.jpg"
                alt="CoderZWei" />
            
              <p class="site-author-name" itemprop="name">CoderZWei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#反转链表"><span class="nav-number">1.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#树的子结构"><span class="nav-number">2.</span> <span class="nav-text">树的子结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈的压入、弹出序列"><span class="nav-number">3.</span> <span class="nav-text">栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二叉树中和为某一值的路径"><span class="nav-number">4.</span> <span class="nav-text">二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对称的二叉树"><span class="nav-number">5.</span> <span class="nav-text">对称的二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#机器人的运动范围"><span class="nav-number">6.</span> <span class="nav-text">机器人的运动范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最大正方形-221"><span class="nav-number">7.</span> <span class="nav-text">最大正方形_221</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#反转链表-206"><span class="nav-number">8.</span> <span class="nav-text">反转链表_206</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造回文"><span class="nav-number">9.</span> <span class="nav-text">构造回文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#求根到叶子节点数字之和-129"><span class="nav-number">10.</span> <span class="nav-text">求根到叶子节点数字之和_129</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#被围绕的去余-130"><span class="nav-number">11.</span> <span class="nav-text">被围绕的去余_130</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#反转字符串里的的单词-151"><span class="nav-number">12.</span> <span class="nav-text">反转字符串里的的单词_151</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#长度最小的子数组-209"><span class="nav-number">13.</span> <span class="nav-text">长度最小的子数组_209</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#n个人n个座位，求不能坐在自己座位上种数"><span class="nav-number">14.</span> <span class="nav-text">n个人n个座位，求不能坐在自己座位上种数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#搜索二维矩阵II-240"><span class="nav-number">15.</span> <span class="nav-text">搜索二维矩阵II_240</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二叉搜索树中第k小的元素-230"><span class="nav-number">16.</span> <span class="nav-text">二叉搜索树中第k小的元素_230</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#累加数-306"><span class="nav-number">17.</span> <span class="nav-text">累加数_306</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最小高度树-310"><span class="nav-number">18.</span> <span class="nav-text">最小高度树_310</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#完全平方数-279"><span class="nav-number">19.</span> <span class="nav-text">完全平方数_279</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最大单词长度乘积-318"><span class="nav-number">20.</span> <span class="nav-text">最大单词长度乘积_318</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#前K个高频元素-347"><span class="nav-number">21.</span> <span class="nav-text">前K个高频元素_347</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#零钱兑换-322"><span class="nav-number">22.</span> <span class="nav-text">零钱兑换_322</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#奇偶链表-328"><span class="nav-number">23.</span> <span class="nav-text">奇偶链表_328</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#比特位计数-338"><span class="nav-number">24.</span> <span class="nav-text">比特位计数_338</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#整数拆分-343"><span class="nav-number">25.</span> <span class="nav-text">整数拆分_343</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查找和最小的K对数字-373"><span class="nav-number">26.</span> <span class="nav-text">查找和最小的K对数字_373</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#水壶问题-365"><span class="nav-number">27.</span> <span class="nav-text">水壶问题_365</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最大整除子集-368"><span class="nav-number">28.</span> <span class="nav-text">最大整除子集_368</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#灯泡开关-319"><span class="nav-number">29.</span> <span class="nav-text">灯泡开关_319</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有序矩阵中的第K小的元素-378"><span class="nav-number">30.</span> <span class="nav-text">有序矩阵中的第K小的元素_378</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#移掉K位数字-402"><span class="nav-number">31.</span> <span class="nav-text">移掉K位数字_402</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#活字印刷"><span class="nav-number">32.</span> <span class="nav-text">活字印刷</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoderZWei</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
