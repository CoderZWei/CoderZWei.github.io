<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="记录leetcode的上做过的一些题的解法思路，防止忘掉">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题笔记">
<meta property="og:url" content="http://yoursite.com/2019/03/30/leetcode刷题笔记/index.html">
<meta property="og:site_name" content="CoderZWei&#39;s blog">
<meta property="og:description" content="记录leetcode的上做过的一些题的解法思路，防止忘掉">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-03-31T15:22:40.213Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="leetcode刷题笔记">
<meta name="twitter:description" content="记录leetcode的上做过的一些题的解法思路，防止忘掉">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/30/leetcode刷题笔记/"/>





  <title>leetcode刷题笔记 | CoderZWei's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CoderZWei's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/30/leetcode刷题笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderZWei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/panpan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoderZWei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">leetcode刷题笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-30T19:17:26+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>记录leetcode的上做过的一些题的解法思路，防止忘掉</p>
<a id="more"></a>
<p>#####113_Path Sum II</p>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>解法：用深搜</p>
<blockquote>
<p>void dfs(TreeNode *root, vector<vector<int>&gt;&amp; res,vector<int>&amp;path,int tmp,int sum){<br>     if(root==NULL){<br>         return;<br>     }<br>     tmp+=root-&gt;val;<br>     path.push_back(root-&gt;val);<br>     if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL &amp;&amp; tmp==sum){<br>         res.push_back(path);<br>     }<br>     dfs(root-&gt;left,res,path,tmp,sum);<br>     dfs(root-&gt;right,res,path,tmp,sum);<br>     path.pop_back();<br> }</int></vector<int></p>
</blockquote>
<p>#####5_最长回文字符串</p>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p>解法：用动态规划</p>
<blockquote>
<p>string longestPalindrome(string s) {<br>    if(s.empty()){<br>        return “”;<br>    }<br>    int len=s.size();<br>    int dp[len][len]={0};<br>    int left=0,right=0,maxLen=0;<br>    for(int i=0;i&lt;len;++i){<br>        for(int j=0;j&lt;i;++j){</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;         if(s[i]==s[j] &amp;&amp; (i-j&lt;2 || dp[j+1][i-1]==1))&#123;</div><div class="line">&gt;             dp[j][i]=1;</div><div class="line">&gt;         &#125;else&#123;</div><div class="line">&gt;             dp[j][i]=0;</div><div class="line">&gt;         &#125;</div><div class="line">&gt;          //dp[j][i] = (s[i] == s[j] &amp;&amp; (i - j &lt; 2 || dp[j + 1][i - 1]));</div><div class="line">&gt;         if(dp[j][i]==1 &amp;&amp; i-j+1&gt;maxLen)&#123;</div><div class="line">&gt;             maxLen=i-j+1;</div><div class="line">&gt;             left=j;</div><div class="line">&gt;             right=i;</div><div class="line">&gt;         &#125;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;     dp[i][i]=1;</div><div class="line">&gt; &#125;</div><div class="line">&gt; return s.substr(left,right-left+1);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>}</p>
</blockquote>
<p>#####16_最接近的三数之和</p>
<p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>解法：</p>
<blockquote>
<p>int threeSumClosest(vector<int>&amp; nums, int target) {<br>     int minDiff=abs(nums[0]+nums[1]+nums[2]-target);<br>     int res=nums[0]+nums[1]+nums[2];<br>     sort(nums.begin(),nums.end());<br>     for(int i=0;i&lt;nums.size()-2;i++){<br>         //int tmp=abs(target-nums[i]);<br>         int left=i+1,right=nums.size()-1;<br>         while(left&lt;right){<br>             int sum=nums[i]+nums[left]+nums[right];<br>             if(abs(sum-target)&lt;minDiff){<br>                 minDiff=abs(sum-target);<br>                 res=sum;<br>             }<br>             if(sum&lt;target){<br>                 left++;<br>             }else{<br>                 right–;<br>             }<br>         }<br>     }<br>     return res;</int></p>
</blockquote>
<p>#####11_盛最多水的容器</p>
<p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em>条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p>
<p>解法：</p>
<blockquote>
<p>int maxArea(vector<int>&amp; height) {<br>     int left=0,right=height.size()-1;<br>     int res=0;<br>     while(left<right){ if(="" (right-left)*(="" min(height[right],height[left])="" )="">res){<br>             res=(right-left)*( min(height[right],height[left]) );<br>         }<br>         if(height[left]&lt;height[right]){<br>             left++;<br>         }else{<br>             right–;<br>         }<br>     }<br>     return res;<br> }</right){></int></p>
</blockquote>
<p>#####22_括号生成</p>
<p>给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p>
<p>解法：用递归</p>
<blockquote>
<p>vector<string> generateParenthesis(int n) {<br>     vector<string>res;<br>     generate(n,n,””,res);<br>     return res;<br> }<br> void generate(int left,int right,string tmp,vector<string>&amp;res){<br>     if(left&gt;right){<br>         return;<br>     }<br>     else if(left==0 &amp;&amp; right==0){<br>         res.push_back(tmp);<br>     }else{<br>         if(left&gt;0){<br>             generate(left-1,right,tmp+’(‘,res);<br>         }<br>         if(right&gt;0){<br>             generate(left,right-1,tmp+’)’,res);<br>         }<br>     }</string></string></string></p>
<p>}</p>
</blockquote>
<p>#####46_全排列</p>
<p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">输入: [1,2,3]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [1,3,2],</div><div class="line">  [2,1,3],</div><div class="line">  [2,3,1],</div><div class="line">  [3,1,2],</div><div class="line">  [3,2,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>解法：用深搜，用visited标记，因为循环是从0开始</p>
<blockquote>
<p>vector<vector<int>&gt; permute(vector<int>&amp; nums) {<br>     sort(nums.begin(),nums.end());<br>     vector<vector<int>&gt;res;<br>     vector<int>tmp;<br>     vector<int> visited(nums.size(),0);<br>     dfs(res,tmp,0,nums,visited);<br>     return res;<br> }<br> void dfs(vector<vector<int>&gt;&amp;res,vector<int>tmp,int level,vector<int>nums,vector<int>visited){<br>     if(level==nums.size()){<br>         res.push_back(tmp);<br>         return;<br>     }<br>     for(int i=0;i&lt;nums.size();i++){<br>         if(visited[i]==1){<br>             continue;<br>         }<br>         visited[i]=1;<br>         tmp.push_back(nums[i]);<br>         dfs(res,tmp,i+1,nums,visited);<br>         tmp.pop_back();<br>         visited[i]=0;<br>     }<br>     return;<br> }</int></int></int></vector<int></int></int></vector<int></int></vector<int></p>
</blockquote>
<p>#####47_全排列II</p>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入: [1,1,2]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [1,1,2],</div><div class="line">  [1,2,1],</div><div class="line">  [2,1,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>解法：用深搜，有点儿麻烦</p>
<blockquote>
<p>vector<vector<int>&gt; permuteUnique(vector<int>&amp; nums) {<br>     sort(nums.begin(),nums.end());<br>     vector<vector<int>&gt;res;<br>     vector<int>tmp;<br>     vector<int>visited(nums.size(),0);<br>     if(nums.empty()){<br>         return res;<br>     }<br>     dfs(res,tmp,nums,visited,0);<br>     return res;<br> }<br> void dfs(vector<vector<int>&gt;&amp;res,vector<int>&amp;tmp,vector<int>nums,vector<int>&amp;visited,int level){<br>     if(level==nums.size()){<br>         res.push_back(tmp);<br>         return ;<br>     }<br>     for(int i=0;i<nums.size();i++){ if(visited[i]="=1){" continue;="" }="" if(i="">0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; visited[i-1]==0){<br>             continue;<br>         }<br>         tmp.push_back(nums[i]);<br>         visited[i]=1;<br>         dfs(res,tmp,nums,visited,level+1);<br>         tmp.pop_back();<br>         visited[i]=0;<br>     }<br>     return;<br> }</nums.size();i++){></int></int></int></vector<int></int></int></vector<int></int></vector<int></p>
</blockquote>
<p>#####78_子集</p>
<p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">输入: nums = [1,2,3]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [3],</div><div class="line">  [1],</div><div class="line">  [2],</div><div class="line">  [1,2,3],</div><div class="line">  [1,3],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure>
<p>解法：用深搜，循环从index开始</p>
<blockquote>
<p>vector<vector<int>&gt; subsets(vector<int>&amp; nums) {<br>    //<a href="http://www.cnblogs.com/grandyang/p/4309345.html" target="_blank" rel="external">http://www.cnblogs.com/grandyang/p/4309345.html</a><br>    sort(nums.begin(),nums.end());<br>    vector<vector<int>&gt;res;<br>    vector<int>tmp;<br>    dfs(res,tmp,nums,0);<br>    return res;<br>}</int></vector<int></int></vector<int></p>
<p>void dfs(vector<vector<int>&gt;&amp;res,vector<int>&amp;tmp,vector<int>nums,int index){<br>        res.push_back(tmp);</int></int></vector<int></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; for(int i=index;i&lt;nums.size();i++)&#123;</div><div class="line">&gt;     tmp.push_back(nums[i]);</div><div class="line">&gt;     dfs(res,tmp,nums,i+1);</div><div class="line">&gt;     tmp.pop_back();</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>}</p>
</blockquote>
<p>#####90_子集||</p>
<p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p>
<p>解法：用深搜加条件判断</p>
<blockquote>
<p>vector<vector<int>&gt; subsetsWithDup(vector<int>&amp; nums) {<br>        sort(nums.begin(),nums.end());<br>        vector<vector<int>&gt;res;<br>        vector<int>tmp;<br>       vector<int>visited(nums.size(),0);<br>        dfs(res,tmp,nums,0,visited);<br>        return res;<br>    }<br>    void dfs(vector<vector<int>&gt;&amp;res,vector<int>tmp,vector<int>&amp; nums,int level,vector<int>&amp;visited){<br>        res.push_back(tmp);<br>        for(int i=level;i<nums.size();i++){ if(visited[i]="=1){" continue;="" }="" if(i="">0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; visited[i-1]==0){<br>                continue;<br>            }<br>            visited[i]=1;<br>            tmp.push_back(nums[i]);<br>            dfs(res,tmp,nums,i+1,visited);<br>            tmp.pop_back();<br>            visited[i]=0;<br>        }<br>    }</nums.size();i++){></int></int></int></vector<int></int></int></vector<int></int></vector<int></p>
</blockquote>
<p>#####9_回文数</p>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: 121</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<p>解法：</p>
<blockquote>
<p>bool isPalindrome(int x) {<br>        if(x<0){ return="" false;="" }="" list<int="">tmp;<br>        while(x&gt;0){<br>            tmp.push_back(x%10);<br>            x=x/10;<br>        }<br>        while(tmp.size()&gt;1){<br>            int top=tmp.front();<br>            tmp.pop_front();<br>            int back=tmp.back();<br>            tmp.pop_back();<br>            if(top!=back){<br>                return false;<br>            }<br>        }<br>        return true;<br>    }</0){></p>
</blockquote>
<p>#####34_在排序数组中查找元素的第一个和最后一个位置</p>
<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>解法：先用二分查找找出位置，再分别向前向后查找</p>
<blockquote>
<p>vector<int> searchRange(vector<int>&amp; nums, int target) {<br>        vector<int>res;<br>        int pos=midSearch(nums,target,0,nums.size()-1);<br>        if(pos==-1){<br>            res.push_back(-1);<br>            res.push_back(-1);<br>            return res;<br>        }<br>        int left=pos,right=pos;<br>        while(left&gt;=0 &amp;&amp; nums[left]==target){<br>            left–;<br>        }<br>        while(right<nums.size() &&="" nums[right]="=target){" right++;="" }="" left++;="" right--;="" res.push_back(left);="" res.push_back(right);="" return="" res;="" int="" midsearch(vector<int="">&amp;nums,int target,int start,int end){<br>        if(start&gt;end){<br>            return -1;<br>        }<br>        int mid=start+(end-start)/2;<br>        if(nums[mid]==target){<br>            return mid;<br>        }else if(nums[mid]&lt;target){<br>            return midSearch(nums,target,mid+1,end);<br>        }else{<br>            return midSearch(nums,target,start,mid-1);<br>        }</nums.size()></int></int></int></p>
<p>}</p>
</blockquote>
<p>#####53_最大子序和</p>
<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p>
<p>解法：用动态规划</p>
<blockquote>
<p>int maxSubArray(vector<int>&amp; nums) {<br>       int dp[nums.size()];<br>        dp[0]=nums[0];<br>        int res=nums[0];<br>        for(int i=1;i&lt;nums.size();i++){<br>            dp[i]=max(nums[i],dp[i-1]+nums[i]);<br>            res=max(res,dp[i]);<br>        }<br>        return res;<br>    }</int></p>
</blockquote>
<p>#####70_爬楼梯</p>
<p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>解法：用动态规划</p>
<blockquote>
<p>int climbStairs(int n) {<br>        //第一步爬1阶(f(n-1)) or 第一步爬2阶(f(n-2))<br>        int map[n+1];<br>        map[1]=1;<br>        if(n&gt;=2){<br>            map[2]=2;<br>        }<br>        if(n&lt;=2){<br>            return map[n];<br>        }<br>        for(int i=3;i&lt;=n;i++){<br>            map[i]=map[i-2]+map[i-1];<br>        }<br>        return map[n];<br>    }</p>
</blockquote>
<p>#####64_最小路径和</p>
<p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>解法：用动态规划，而不是深搜</p>
<blockquote>
<p>int minPathSum(vector<vector<int>&gt;&amp; grid) {<br>        //int res=INT_MAX;<br>        //dfs(grid,0,0,grid[0][0],&amp;res);<br>        //return res;<br>          int m = grid.size(), n = grid[0].size();<br>        int dp[m][n];<br>        dp[0][0] = grid[0][0];<br>        for (int i = 1; i &lt; m; ++i) dp[i][0] = grid[i][0] + dp[i - 1][0];<br>        for (int i = 1; i &lt; n; ++i) dp[0][i] = grid[0][i] + dp[0][i - 1];<br>        for (int i = 1; i &lt; m; ++i) {<br>            for (int j = 1; j &lt; n; ++j) {<br>                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);<br>            }<br>        }<br>        return dp[m - 1][n - 1];<br>    }<br>    /<em><br>    void dfs(vector<vector<int>&gt;&amp; grid,int x,int y,int len,int </vector<int></em>res){<br>        if(x==grid.size()-1 &amp;&amp; y==grid[0].size()-1){<br>            if(len&lt;<em>res){
               </em>res=len;<br>            }<br>            return;<br>        }<br>        if(x&lt;grid.size()-1){<br>            dfs(grid,x+1,y,len+grid[x+1][y],res);<br>        }<br>         if(y&lt;grid[0].size()-1){<br>            dfs(grid,x,y+1,len+grid[x][y+1],res);<br>        }<br>    }<br>    */</vector<int></p>
</blockquote>
<p>#####92_反转链表II</p>
<p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转</p>
<p>解法：指针的操作，记得设一个指针指向头指针，防止反转的起点头指针</p>
<blockquote>
<p>ListNode<em> reverseBetween(ListNode</em> head, int m, int n) {<br>        //用快慢指针<br>       ListNode <em>dummy=new ListNode(-1),</em>pre=dummy;<br>        pre-&gt;next=head;<br>        for(int i=0;i<m-1;i++){ pre="pre-">next;</m-1;i++){></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    &#125;</div><div class="line">   ListNode *cur=pre-&gt;next;</div><div class="line">    for(int i=m;i&lt;n;i++)&#123;</div><div class="line">        ListNode *t=cur-&gt;next;</div><div class="line">        cur-&gt;next=t-&gt;next;</div><div class="line">        t-&gt;next=pre-&gt;next;</div><div class="line">        pre-&gt;next=t;</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">    return dummy-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####63_不同路径II(三星研究院的题目，当时用的是深搜)</p>
<p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>解法：</p>
<p>用动态规划，dp[i][j] = dp[i-1][j] + dp[i][j-1]</p>
<blockquote>
<p>int uniquePathsWithObstacles(vector<vector<int>&gt;&amp; obstacleGrid) {<br>        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) return 0;<br>        int m = obstacleGrid.size(), n = obstacleGrid[0].size();<br>        vector<vector<long>&gt; dp(m + 1, vector<long>(n + 1, 0));<br>        dp[0][1] = 1;<br>        for (int i = 1; i &lt;= m; ++i) {<br>            for (int j = 1; j &lt;= n; ++j) {<br>                if (obstacleGrid[i - 1][j - 1] != 0) continue;<br>                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];<br>            }<br>        }<br>        return dp[m][n];<br>    }</long></vector<long></vector<int></p>
</blockquote>
<p>#####56_合并区间</p>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<blockquote>
<p> vector<interval> merge(vector<interval>&amp; intervals) {<br>        if (intervals.empty()) return {};<br>        sort(intervals.begin(), intervals.end(), <a href="Interval &amp;a, Interval &amp;b"></a> {return a.start &lt; b.start;});<br>        vector<interval> res{intervals[0]};<br>        for (int i = 1; i &lt; intervals.size(); ++i) {<br>            if (res.back().end &lt; intervals[i].start) {<br>                res.push_back(intervals[i]);<br>            } else {<br>                res.back().end = max(res.back().end, intervals[i].end);<br>            }<br>        }<br>        return res;<br>    }</interval></interval></interval></p>
</blockquote>
<p>#####80_删除排序数组中的重复项||</p>
<p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>解法：做一个标记(flag)，记录那些出现过但是次数没有达到2次的元素</p>
<blockquote>
<p>int removeDuplicates(vector<int>&amp; nums) {<br>        if(nums.size()&lt;2){<br>            return nums.size();<br>        }<br>        int tmp=nums[0];<br>        int  flag=0;//标记<br>        for(int i=1;i&lt;nums.size();i++){<br>            if(nums[i]==tmp){//相等的时候<br>                if(flag==0){<br>                    flag=1;<br>                }else{<br>                    nums.erase(nums.begin()+i);<br>                    i–;<br>                }<br>            }else{<br>                tmp=nums[i];<br>                flag=0;<br>            }</int></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    &#125;</div><div class="line">    return nums.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####101_对称二叉树</p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>解法：递归判断 root-&gt;left-&gt;left和root-&gt;right-&gt;right对应</p>
<blockquote>
<p>bool isSymmetric(TreeNode<em> root) {<br>     if (!root) return true;<br>        return isSymmetric(root-&gt;left, root-&gt;right);<br>    }<br>bool isSymmetric(TreeNode </em>left, TreeNode *right) {<br>        if (!left &amp;&amp; !right) return true;<br>        if (left &amp;&amp; !right || !left &amp;&amp; right || left-&gt;val != right-&gt;val) return false;<br>        return isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;left);<br>    }</p>
</blockquote>
<p>#####137_只出现一次的数字II</p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>解法：建立一个32位的数字(int型)，来统计每一位上1出现的个数。如果某一位上为1的话，那么如果该整数出现了3次，对3去余则为0，若出现4次则为1，我们把每个数的对应位都加起来对3取余，最终剩下来的那个数就是单独的数字</p>
<blockquote>
<p>int singleNumber(vector<int>&amp; nums) {<br>      int res = 0;<br>        for (int i = 0; i &lt; 32; ++i) {<br>            int sum = 0;<br>            for (int j = 0; j &lt; nums.size(); ++j) {<br>                sum += (nums[j] &gt;&gt; i) &amp; 1;<br>            }<br>            res |= (sum % 3) &lt;&lt; i;<br>        }<br>        return res;<br>    }</int></p>
</blockquote>
<p>#####152_乘积最大子序列</p>
<p>给定一个整数数组 <code>nums</code> (包含负数、0)，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
<p>解法：使用动态规划，因为很小的负数乘一个负数会成一个很大的正数，因此建立两个数组，一个记录连乘最小的数，一个记录连乘最大的数。</p>
<blockquote>
<p>//<a href="http://www.cnblogs.com/grandyang/p/4028713.html" target="_blank" rel="external">http://www.cnblogs.com/grandyang/p/4028713.html</a><br>    int maxProduct(vector<int>&amp; nums) {<br>        int n=nums.size();<br>        int res=nums[0];<br>        vector<int>dp_max(n,0),dp_min(n,0);<br>        dp_max[0]=res;<br>        dp_min[0]=res;<br>        for(int i=1;i&lt;nums.size();i++){<br>           dp_max[i]=max(nums[i],max(nums[i]<em>dp_max[i-1],nums[i]</em>dp_min[i-1]));<br>           dp_min[i]=min(nums[i],min(nums[i]<em>dp_max[i-1],nums[i]</em>dp_min[i-1]));<br>           res=max(res,dp_max[i]);<br>        }<br>        return res;<br>    }</int></int></p>
</blockquote>
<p>#####179_最大数</p>
<p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p>
<p>如：输入：[10,2]    输出：210</p>
<p>解法：将数字转换为字符串相加排序进行排序，序高者在前</p>
<blockquote>
<p>static bool cmp(int a,int b){<br>        return to_string(a) + to_string(b) &gt; to_string(b) + to_string(a);<br>    }<br>    string largestNumber(vector<int>&amp; nums) {<br>        sort(nums.begin(),nums.end(),cmp);<br>        string res=””;<br>        for(int i=0;i&lt;nums.size();i++){<br>            res+=to_string(nums[i]);<br>        }<br>        return res;</int></p>
</blockquote>
<p>#####200_岛屿的个数</p>
<p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入:</div><div class="line">11110</div><div class="line">11010</div><div class="line">11000</div><div class="line">00000</div><div class="line"></div><div class="line">输出: 1</div></pre></td></tr></table></figure>
<p>解法：使用深搜，记住不是动态规划</p>
<blockquote>
<p>int numIslands(vector<vector<char>&gt;&amp; grid) {<br>          if (grid.empty() || grid[0].empty()) return 0;<br>        int m=grid.size(),n=grid[0].size();<br>        int res=0;<br>       vector<vector<int>&gt;visited(m,vector<int>(n,0));<br>        for(int i=0;i<m;i++){ for(int="" j="0;j<n;j++){" if(grid[i][j]="='1'" &&="" visited[i][j]="=0){" dfs(grid,i,j,visited);="" res++;="" }="" return="" res;="" void="" dfs(vector<vector<char="">&gt;&amp; grid,int x,int y,vector<vector<int>&gt;&amp;visited){<br>        if(x&gt;=grid.size()||y&gt;=grid[0].size()||x&lt;0||y&lt;0){<br>            return ;<br>        }<br>        if(grid[x][y]==’0’||visited[x][y]==1){//不通或者已访问过<br>            return;<br>        }<br>        visited[x][y]=1;<br>        dfs(grid,x+1,y,visited);<br>        dfs(grid,x,y+1,visited);<br>        dfs(grid,x,y-1,visited);<br>        dfs(grid,x-1,y,visited);<br>    }</vector<int></m;i++){></int></vector<int></vector<char></p>
</blockquote>
<p>#####重建二叉树</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>解法：</p>
<blockquote>
<p>TreeNode<em> reConstructBinaryTree(vector<int> pre,vector<int> vin) {<br>           TreeNode </int></int></em>root=reConstructBinaryTree(pre,0,pre.size()-1,vin,0,vin.size()-1);<br>            return root;<br>    }<br>    TreeNode <em> reConstructBinaryTree(vector<int> pre,int start_pre,int end_pre,vector<int> vin,int start_vin,int end_vin){<br>        if(start_pre&gt;end_pre || start_vin&gt;end_vin){<br>            return NULL;<br>        }<br>        TreeNode </int></int></em>root=new TreeNode(pre[start_pre]);<br>        for(int i=start_vin;i&lt;=end_vin;i++)<br>            if(vin[i]==pre[start_pre]){<br>                root-&gt;left=reConstructBinaryTree(pre,start_pre+1,start_pre+i-start_vin,vin,start_vin,i-1);<br>                root-&gt;right=reConstructBinaryTree(pre,i-start_vin+start_pre+1,end_pre,vin,i+1,end_vin);<br>                break;</p>
<p>​    }</p>
<p>return root;<br>}</p>
</blockquote>
<p>#####用两个栈实现队列的功能(先进先出)</p>
<p>解法：</p>
<p>入队：将元素进栈A</p>
<p>出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；</p>
<p>如果不为空，栈B直接出栈。</p>
<blockquote>
<p> void push(int node) {<br>          stack1.push(node);<br>     }</p>
</blockquote>
<pre><code>int pop() {
      int a;
    if(stack2.empty()){
        while(!stack1.empty()){
            a=stack1.top();
            stack2.push(a);
            stack1.pop();
        }
    }
    a=stack2.top();
    stack2.pop();
    return a;
}
</code></pre><p>private:<br>    stack<int> stack1;<br>    stack<int> stack2;</int></int></p>
<p>#####矩形覆盖</p>
<p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p>解法：用动态规划，f(n)=f(n-1)+f(n-2)</p>
<blockquote>
<p> int rectCover(int number) {<br>         if(number==0){<br>             return 0;<br>         }<br>         if(number  == 1){<br>             return 1;<br>         }<br>         if(number<em>2 == 2){<br>             return 1;<br>         }else if(number</em>2 == 4){<br>             return 2;<br>         }else{<br>             return rectCover((number-1))+rectCover(number-2);<br>         }<br>     }</p>
</blockquote>
<p>#####二进制中1的个数</p>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">-------------可能陷入死循环的解法---------------------</div><div class="line">//可能陷入死循环的方法是因为&gt;&gt;右移是带符号位右移的导致，右移空出来的位子都是1所以进入死循环。如果把n=n&gt;&gt;1改成n=n&gt;&gt;&gt;1就不会进入死循环了。&gt;&gt;&gt;是无视符号的右移</div><div class="line">    /*public static int NumberOf1_CanNotUse(int n) &#123;</div><div class="line">        int count = 0;</div><div class="line">        while (n != 0) &#123;</div><div class="line">            /*</div><div class="line">            * 用1和n进行位与运算，</div><div class="line">            * 结果要是为1则n的2进制形式</div><div class="line">            * 最右边那位肯定是1，否则为0</div><div class="line">            */</div><div class="line">            if((n &amp; 1) == 1) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            //把n的2进制形式往右推一位</div><div class="line">            n = n &gt;&gt; 1;</div><div class="line">        &#125;</div><div class="line">        return count;</div><div class="line">    &#125;*/</div><div class="line">    //---------------正解--------------------------------</div><div class="line">    //思想：用1（1自身左移运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数</div><div class="line">    private static int NumberOf1_low( int n) &#123;</div><div class="line">        int count = 0;</div><div class="line">        int flag = 1;</div><div class="line">        while (flag != 0) &#123;</div><div class="line">            if ((n &amp; flag) != 0) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            flag = flag &lt;&lt; 1;</div><div class="line">        &#125;</div><div class="line">        return` `count;</div><div class="line">    &#125;</div><div class="line">    //--------------------最优解----------------------------</div><div class="line">    public static int NumberOf1(int n) &#123;</div><div class="line">        int count = 0;</div><div class="line">        while (n != 0) &#123;</div><div class="line">            ++count;</div><div class="line">            n = (n - 1) &amp; n;</div><div class="line">        &#125;</div><div class="line">        return count;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>#####调整数组顺序使奇数位于偶数的前面</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>解法：从左向右遍历，若遇到偶数，则从数组中删除，并将其加到数组末尾</p>
<blockquote>
<p>void reOrderArray(vector<int> &amp;array) {<br>      int n=array.size(),i=0;<br>      while(i&lt;n){<br>          if(array[i]%2==0){<br>              int tmp=array[i];<br>              array.erase(array.begin()+i);<br>              array.push_back(tmp);<br>              n–;<br>              i–;<br>          }<br>            i++;<br>      }<br>   }</int></p>
</blockquote>
<p>#####链表中倒数第k个结点</p>
<p>解法：可使用快慢指针，快指针先走k个节点，然后两个节点一起走，当快节点到达末尾时，满节点就到达了倒数第k个节点</p>
<h5 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h5><p> ListNode<em> ReverseList(ListNode</em> pHead) {<br>        if(pHead==NULL || pHead-&gt;next==NULL){<br>            return pHead;<br>        }      </p>
<pre><code>    ListNode *cur=pHead,*curNext=pHead-&gt;next;
    cur-&gt;next=NULL;
    while(curNext){
       ListNode *tmp=curNext;
        curNext=curNext-&gt;next;
        tmp-&gt;next=cur;
        cur=tmp;
    }
    return cur;
}
</code></pre><h5 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h5><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">bool isSubtree(TreeNode* pRootA, TreeNode* pRootB) &#123;</div><div class="line">        if (pRootB == NULL) return true;</div><div class="line">        if (pRootA == NULL) return false;</div><div class="line">        if (pRootB-&gt;val == pRootA-&gt;val) &#123;</div><div class="line">            return isSubtree(pRootA-&gt;left, pRootB-&gt;left)</div><div class="line">                &amp;&amp; isSubtree(pRootA-&gt;right, pRootB-&gt;right);</div><div class="line">        &#125; else return false;</div><div class="line">    &#125;</div><div class="line">bool HasSubtree(TreeNode* pRootA, TreeNode* pRootB)</div><div class="line">    &#123;</div><div class="line">        if (pRootA == NULL || pRootB == NULL) return false;</div><div class="line">        	return isSubtree(pRootA, pRootB) ||</div><div class="line">            HasSubtree(pRootA-&gt;left, pRootB) ||</div><div class="line">            HasSubtree(pRootA-&gt;right, pRootB);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h5><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>解法：顺序遍历压入序列，将其压入栈，当栈顶元素和弹出序列头部相等时，栈弹出。最终若栈为空，则返回true</p>
<blockquote>
<p> bool IsPopOrder(vector<int> pushV,vector<int> popV) {<br>         stack<int>st;<br>         int t=0;<br>         for(int i=0;i&lt;pushV.size();i++){<br>             st.push(pushV[i]);<br>             while(t&lt;popV.size()  &amp;&amp; st.top()==popV[t]){<br>                 st.pop();<br>                 t++;<br>             }<br>         }<br>         if(st.size()==0){<br>             return true;<br>         }else{<br>             return false;<br>         }<br>     }</int></int></int></p>
</blockquote>
<h5 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h5><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<p>解法：使用深搜</p>
<blockquote>
<p>vector<vector<int> &gt;allRes;<br>    vector<int> tmp;<br>    void dfsFind(TreeNode <em> node , int left){<br>        tmp.push_back(node-&gt;val);<br>        if(left-node-&gt;val == 0 &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right)<br>            allRes.push_back(tmp);<br>        else {<br>            if(node-&gt;left) dfsFind(node-&gt;left, left-node-&gt;val);<br>            if(node-&gt;right) dfsFind(node-&gt;right, left-node-&gt;val);<br>        }<br>        tmp.pop_back();<br>    }<br>    vector<vector<int> &gt; FindPath(TreeNode</vector<int></em> root,int expectNumber) {<br>         if(root) dfsFind(root, expectNumber);<br>        return allRes;<br>    }</int></vector<int></p>
</blockquote>
<h5 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h5><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>解法：递归</p>
<blockquote>
<p>bool isSymmetrical(TreeNode<em> pRoot)<br>    {<br>        if(pRoot == NULL){<br>                return true;<br>            }<br>            return comRoot(pRoot-&gt;left, pRoot-&gt;right);<br>      }<br>      bool comRoot(TreeNode </em>left, TreeNode *right) {<br>            // TODO Auto-generated method stub<br>            if(left == NULL) return right==NULL;<br>            if(right == NULL) return false;<br>            if(left-&gt;val != right-&gt;val) return false;<br>            return comRoot(left-&gt;right,right-&gt;left) &amp;&amp; comRoot(left-&gt;left,right-&gt;right);<br>        }</p>
</blockquote>
<h5 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h5><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>解法：使用深搜，用visited数组记录是否访问过</p>
<blockquote>
<p> int movingCount(int threshold, int rows, int cols)<br>   {<br>      int visited[rows<em>cols];<br>       memset(visited, 0, sizeof(visited));<br>       return dfs(threshold,1,1,rows,cols,visited);<br>   }<br> int func(int n){<br>       int res=0;<br>       while(n&gt;0){<br>           res+=n%10;<br>           n=n/10;<br>       }<br>       return res;<br>   }<br>   int dfs(int threshold,int x,int y,int row,int col,int visited[]){<br>       cout&lt;&lt;”heihei x=”&lt;<x<<"y="<<y<<endl; 因为是从(0,0开始的，所以要func(x-1)="" func(y-1)="" if(x<1="" ||="" y<1="" x="">row || y&gt;col || visited[(x-1)</x<<"y="<<y<<endl;></em>col+(y-1)]==1 || func(x-1)+func(y-1)&gt;threshold){<br>           return 0;<br>       }<br>       cout&lt;&lt;”x:”&lt;&lt;x&lt;&lt;”y”&lt;&lt;y&lt;&lt;endl;<br>       visited[(x-1)*col+(y-1)]=1;<br>       return dfs(threshold,x,y+1,row,col,visited)+<br>       dfs(threshold,x,y-1,row,col,visited)+<br>       dfs(threshold,x-1,y,row,col,visited)+<br>       dfs(threshold,x+1,y,row,col,visited)+1;<br>   }</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/13/Java中extend与implements的区别/" rel="next" title="Java中extend与implements的区别">
                <i class="fa fa-chevron-left"></i> Java中extend与implements的区别
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/panpan.jpg"
                alt="CoderZWei" />
            
              <p class="site-author-name" itemprop="name">CoderZWei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#反转链表"><span class="nav-number">1.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#树的子结构"><span class="nav-number">2.</span> <span class="nav-text">树的子结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈的压入、弹出序列"><span class="nav-number">3.</span> <span class="nav-text">栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二叉树中和为某一值的路径"><span class="nav-number">4.</span> <span class="nav-text">二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对称的二叉树"><span class="nav-number">5.</span> <span class="nav-text">对称的二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#机器人的运动范围"><span class="nav-number">6.</span> <span class="nav-text">机器人的运动范围</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoderZWei</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
