<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="113、Path Sum II 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 解法：用深搜  void dfs(TreeNode *root, vector">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题笔记">
<meta property="og:url" content="http://yoursite.com/2019/03/30/leetcode刷题笔记/index.html">
<meta property="og:site_name" content="CoderZWei&#39;s blog">
<meta property="og:description" content="113、Path Sum II 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 解法：用深搜  void dfs(TreeNode *root, vector">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-03-30T11:18:00.274Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="leetcode刷题笔记">
<meta name="twitter:description" content="113、Path Sum II 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 解法：用深搜  void dfs(TreeNode *root, vector">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/30/leetcode刷题笔记/"/>





  <title>leetcode刷题笔记 | CoderZWei's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CoderZWei's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/30/leetcode刷题笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderZWei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/panpan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoderZWei's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">leetcode刷题笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-30T19:17:26+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<p>113、Path Sum II</p>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>解法：用深搜</p>
<blockquote>
<p>void dfs(TreeNode *root, vector<vector<int>&gt;&amp; res,vector<int>&amp;path,int tmp,int sum){<br>     if(root==NULL){<br>         return;<br>     }<br>     tmp+=root-&gt;val;<br>     path.push_back(root-&gt;val);<br>     if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL &amp;&amp; tmp==sum){<br>         res.push_back(path);<br>     }<br>     dfs(root-&gt;left,res,path,tmp,sum);<br>     dfs(root-&gt;right,res,path,tmp,sum);<br>     path.pop_back();<br> }</int></vector<int></p>
</blockquote>
<p>5、最长回文字符串</p>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p>解法：用动态规划</p>
<blockquote>
<p>string longestPalindrome(string s) {<br>    if(s.empty()){<br>        return “”;<br>    }<br>    int len=s.size();<br>    int dp[len][len]={0};<br>    int left=0,right=0,maxLen=0;<br>    for(int i=0;i&lt;len;++i){<br>        for(int j=0;j&lt;i;++j){</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;         if(s[i]==s[j] &amp;&amp; (i-j&lt;2 || dp[j+1][i-1]==1))&#123;</div><div class="line">&gt;             dp[j][i]=1;</div><div class="line">&gt;         &#125;else&#123;</div><div class="line">&gt;             dp[j][i]=0;</div><div class="line">&gt;         &#125;</div><div class="line">&gt;          //dp[j][i] = (s[i] == s[j] &amp;&amp; (i - j &lt; 2 || dp[j + 1][i - 1]));</div><div class="line">&gt;         if(dp[j][i]==1 &amp;&amp; i-j+1&gt;maxLen)&#123;</div><div class="line">&gt;             maxLen=i-j+1;</div><div class="line">&gt;             left=j;</div><div class="line">&gt;             right=i;</div><div class="line">&gt;         &#125;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;     dp[i][i]=1;</div><div class="line">&gt; &#125;</div><div class="line">&gt; return s.substr(left,right-left+1);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>}</p>
</blockquote>
<p>16、最接近的三数之和</p>
<p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>解法：</p>
<blockquote>
<p>int threeSumClosest(vector<int>&amp; nums, int target) {<br>     int minDiff=abs(nums[0]+nums[1]+nums[2]-target);<br>     int res=nums[0]+nums[1]+nums[2];<br>     sort(nums.begin(),nums.end());<br>     for(int i=0;i&lt;nums.size()-2;i++){<br>         //int tmp=abs(target-nums[i]);<br>         int left=i+1,right=nums.size()-1;<br>         while(left&lt;right){<br>             int sum=nums[i]+nums[left]+nums[right];<br>             if(abs(sum-target)&lt;minDiff){<br>                 minDiff=abs(sum-target);<br>                 res=sum;<br>             }<br>             if(sum&lt;target){<br>                 left++;<br>             }else{<br>                 right–;<br>             }<br>         }<br>     }<br>     return res;</int></p>
</blockquote>
<p>11、盛最多水的容器</p>
<p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em>条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p>
<p>解法：</p>
<blockquote>
<p>int maxArea(vector<int>&amp; height) {<br>     int left=0,right=height.size()-1;<br>     int res=0;<br>     while(left<right){ if(="" (right-left)*(="" min(height[right],height[left])="" )="">res){<br>             res=(right-left)*( min(height[right],height[left]) );<br>         }<br>         if(height[left]&lt;height[right]){<br>             left++;<br>         }else{<br>             right–;<br>         }<br>     }<br>     return res;<br> }</right){></int></p>
</blockquote>
<p>22、括号生成</p>
<p>给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p>
<p>解法：用递归</p>
<blockquote>
<p>vector<string> generateParenthesis(int n) {<br>     vector<string>res;<br>     generate(n,n,””,res);<br>     return res;<br> }<br> void generate(int left,int right,string tmp,vector<string>&amp;res){<br>     if(left&gt;right){<br>         return;<br>     }<br>     else if(left==0 &amp;&amp; right==0){<br>         res.push_back(tmp);<br>     }else{<br>         if(left&gt;0){<br>             generate(left-1,right,tmp+’(‘,res);<br>         }<br>         if(right&gt;0){<br>             generate(left,right-1,tmp+’)’,res);<br>         }<br>     }</string></string></string></p>
<p>}</p>
</blockquote>
<p>46、全排列</p>
<p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">输入: [1,2,3]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [1,3,2],</div><div class="line">  [2,1,3],</div><div class="line">  [2,3,1],</div><div class="line">  [3,1,2],</div><div class="line">  [3,2,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>解法：用深搜，用visited标记，因为循环是从0开始</p>
<blockquote>
<p>vector<vector<int>&gt; permute(vector<int>&amp; nums) {<br>     sort(nums.begin(),nums.end());<br>     vector<vector<int>&gt;res;<br>     vector<int>tmp;<br>     vector<int> visited(nums.size(),0);<br>     dfs(res,tmp,0,nums,visited);<br>     return res;<br> }<br> void dfs(vector<vector<int>&gt;&amp;res,vector<int>tmp,int level,vector<int>nums,vector<int>visited){<br>     if(level==nums.size()){<br>         res.push_back(tmp);<br>         return;<br>     }<br>     for(int i=0;i&lt;nums.size();i++){<br>         if(visited[i]==1){<br>             continue;<br>         }<br>         visited[i]=1;<br>         tmp.push_back(nums[i]);<br>         dfs(res,tmp,i+1,nums,visited);<br>         tmp.pop_back();<br>         visited[i]=0;<br>     }<br>     return;<br> }</int></int></int></vector<int></int></int></vector<int></int></vector<int></p>
</blockquote>
<p>47、全排列II</p>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入: [1,1,2]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [1,1,2],</div><div class="line">  [1,2,1],</div><div class="line">  [2,1,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>解法：用深搜，有点儿麻烦</p>
<blockquote>
<p>vector<vector<int>&gt; permuteUnique(vector<int>&amp; nums) {<br>     sort(nums.begin(),nums.end());<br>     vector<vector<int>&gt;res;<br>     vector<int>tmp;<br>     vector<int>visited(nums.size(),0);<br>     if(nums.empty()){<br>         return res;<br>     }<br>     dfs(res,tmp,nums,visited,0);<br>     return res;<br> }<br> void dfs(vector<vector<int>&gt;&amp;res,vector<int>&amp;tmp,vector<int>nums,vector<int>&amp;visited,int level){<br>     if(level==nums.size()){<br>         res.push_back(tmp);<br>         return ;<br>     }<br>     for(int i=0;i<nums.size();i++){ if(visited[i]="=1){" continue;="" }="" if(i="">0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; visited[i-1]==0){<br>             continue;<br>         }<br>         tmp.push_back(nums[i]);<br>         visited[i]=1;<br>         dfs(res,tmp,nums,visited,level+1);<br>         tmp.pop_back();<br>         visited[i]=0;<br>     }<br>     return;<br> }</nums.size();i++){></int></int></int></vector<int></int></int></vector<int></int></vector<int></p>
</blockquote>
<p>78、子集</p>
<p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">输入: nums = [1,2,3]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [3],</div><div class="line">  [1],</div><div class="line">  [2],</div><div class="line">  [1,2,3],</div><div class="line">  [1,3],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure>
<p>解法：用深搜，循环从index开始</p>
<blockquote>
<p>vector<vector<int>&gt; subsets(vector<int>&amp; nums) {<br>    //<a href="http://www.cnblogs.com/grandyang/p/4309345.html" target="_blank" rel="external">http://www.cnblogs.com/grandyang/p/4309345.html</a><br>    sort(nums.begin(),nums.end());<br>    vector<vector<int>&gt;res;<br>    vector<int>tmp;<br>    dfs(res,tmp,nums,0);<br>    return res;<br>}</int></vector<int></int></vector<int></p>
<p>void dfs(vector<vector<int>&gt;&amp;res,vector<int>&amp;tmp,vector<int>nums,int index){<br>        res.push_back(tmp);</int></int></vector<int></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; for(int i=index;i&lt;nums.size();i++)&#123;</div><div class="line">&gt;     tmp.push_back(nums[i]);</div><div class="line">&gt;     dfs(res,tmp,nums,i+1);</div><div class="line">&gt;     tmp.pop_back();</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>}</p>
</blockquote>
<p>90、子集||</p>
<p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p>
<p>解法：用深搜加条件判断</p>
<blockquote>
<p>vector<vector<int>&gt; subsetsWithDup(vector<int>&amp; nums) {<br>        sort(nums.begin(),nums.end());<br>        vector<vector<int>&gt;res;<br>        vector<int>tmp;<br>       vector<int>visited(nums.size(),0);<br>        dfs(res,tmp,nums,0,visited);<br>        return res;<br>    }<br>    void dfs(vector<vector<int>&gt;&amp;res,vector<int>tmp,vector<int>&amp; nums,int level,vector<int>&amp;visited){<br>        res.push_back(tmp);<br>        for(int i=level;i<nums.size();i++){ if(visited[i]="=1){" continue;="" }="" if(i="">0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; visited[i-1]==0){<br>                continue;<br>            }<br>            visited[i]=1;<br>            tmp.push_back(nums[i]);<br>            dfs(res,tmp,nums,i+1,visited);<br>            tmp.pop_back();<br>            visited[i]=0;<br>        }<br>    }</nums.size();i++){></int></int></int></vector<int></int></int></vector<int></int></vector<int></p>
</blockquote>
<p>9、回文数</p>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: 121</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<p>解法：</p>
<blockquote>
<p>bool isPalindrome(int x) {<br>        if(x<0){ return="" false;="" }="" list<int="">tmp;<br>        while(x&gt;0){<br>            tmp.push_back(x%10);<br>            x=x/10;<br>        }<br>        while(tmp.size()&gt;1){<br>            int top=tmp.front();<br>            tmp.pop_front();<br>            int back=tmp.back();<br>            tmp.pop_back();<br>            if(top!=back){<br>                return false;<br>            }<br>        }<br>        return true;<br>    }</0){></p>
</blockquote>
<p>34、给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>解法：先用二分查找找出位置，再分别向前向后查找</p>
<blockquote>
<p>vector<int> searchRange(vector<int>&amp; nums, int target) {<br>        vector<int>res;<br>        int pos=midSearch(nums,target,0,nums.size()-1);<br>        if(pos==-1){<br>            res.push_back(-1);<br>            res.push_back(-1);<br>            return res;<br>        }<br>        int left=pos,right=pos;<br>        while(left&gt;=0 &amp;&amp; nums[left]==target){<br>            left–;<br>        }<br>        while(right<nums.size() &&="" nums[right]="=target){" right++;="" }="" left++;="" right--;="" res.push_back(left);="" res.push_back(right);="" return="" res;="" int="" midsearch(vector<int="">&amp;nums,int target,int start,int end){<br>        if(start&gt;end){<br>            return -1;<br>        }<br>        int mid=start+(end-start)/2;<br>        if(nums[mid]==target){<br>            return mid;<br>        }else if(nums[mid]&lt;target){<br>            return midSearch(nums,target,mid+1,end);<br>        }else{<br>            return midSearch(nums,target,start,mid-1);<br>        }</nums.size()></int></int></int></p>
<p>}</p>
</blockquote>
<p>53、最大子序和</p>
<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p>
<p>解法：用动态规划</p>
<blockquote>
<p>int maxSubArray(vector<int>&amp; nums) {<br>       int dp[nums.size()];<br>        dp[0]=nums[0];<br>        int res=nums[0];<br>        for(int i=1;i&lt;nums.size();i++){<br>            dp[i]=max(nums[i],dp[i-1]+nums[i]);<br>            res=max(res,dp[i]);<br>        }<br>        return res;<br>    }</int></p>
</blockquote>
<p>70、爬楼梯</p>
<p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>解法：用动态规划</p>
<blockquote>
<p>int climbStairs(int n) {<br>        //第一步爬1阶(f(n-1)) or 第一步爬2阶(f(n-2))<br>        int map[n+1];<br>        map[1]=1;<br>        if(n&gt;=2){<br>            map[2]=2;<br>        }<br>        if(n&lt;=2){<br>            return map[n];<br>        }<br>        for(int i=3;i&lt;=n;i++){<br>            map[i]=map[i-2]+map[i-1];<br>        }<br>        return map[n];<br>    }</p>
</blockquote>
<p>64、最小路径和</p>
<p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>解法：用动态规划，而不是深搜</p>
<blockquote>
<p>int minPathSum(vector<vector<int>&gt;&amp; grid) {<br>        //int res=INT_MAX;<br>        //dfs(grid,0,0,grid[0][0],&amp;res);<br>        //return res;<br>          int m = grid.size(), n = grid[0].size();<br>        int dp[m][n];<br>        dp[0][0] = grid[0][0];<br>        for (int i = 1; i &lt; m; ++i) dp[i][0] = grid[i][0] + dp[i - 1][0];<br>        for (int i = 1; i &lt; n; ++i) dp[0][i] = grid[0][i] + dp[0][i - 1];<br>        for (int i = 1; i &lt; m; ++i) {<br>            for (int j = 1; j &lt; n; ++j) {<br>                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);<br>            }<br>        }<br>        return dp[m - 1][n - 1];<br>    }<br>    /<em><br>    void dfs(vector<vector<int>&gt;&amp; grid,int x,int y,int len,int </vector<int></em>res){<br>        if(x==grid.size()-1 &amp;&amp; y==grid[0].size()-1){<br>            if(len&lt;<em>res){
               </em>res=len;<br>            }<br>            return;<br>        }<br>        if(x&lt;grid.size()-1){<br>            dfs(grid,x+1,y,len+grid[x+1][y],res);<br>        }<br>         if(y&lt;grid[0].size()-1){<br>            dfs(grid,x,y+1,len+grid[x][y+1],res);<br>        }<br>    }<br>    */</vector<int></p>
</blockquote>
<p>92、反转链表II</p>
<p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转</p>
<p>解法：指针的操作，记得设一个指针指向头指针，防止反转的起点头指针</p>
<blockquote>
<p>ListNode<em> reverseBetween(ListNode</em> head, int m, int n) {<br>        //用快慢指针<br>       ListNode <em>dummy=new ListNode(-1),</em>pre=dummy;<br>        pre-&gt;next=head;<br>        for(int i=0;i<m-1;i++){ pre="pre-">next;</m-1;i++){></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    &#125;</div><div class="line">   ListNode *cur=pre-&gt;next;</div><div class="line">    for(int i=m;i&lt;n;i++)&#123;</div><div class="line">        ListNode *t=cur-&gt;next;</div><div class="line">        cur-&gt;next=t-&gt;next;</div><div class="line">        t-&gt;next=pre-&gt;next;</div><div class="line">        pre-&gt;next=t;</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">    return dummy-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>63、不同路径II(三星研究院的题目，当时用的是深搜)</p>
<p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>解法：</p>
<p>用动态规划，dp[i][j] = dp[i-1][j] + dp[i][j-1]</p>
<blockquote>
<p>int uniquePathsWithObstacles(vector<vector<int>&gt;&amp; obstacleGrid) {<br>        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) return 0;<br>        int m = obstacleGrid.size(), n = obstacleGrid[0].size();<br>        vector<vector<long>&gt; dp(m + 1, vector<long>(n + 1, 0));<br>        dp[0][1] = 1;<br>        for (int i = 1; i &lt;= m; ++i) {<br>            for (int j = 1; j &lt;= n; ++j) {<br>                if (obstacleGrid[i - 1][j - 1] != 0) continue;<br>                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];<br>            }<br>        }<br>        return dp[m][n];<br>    }</long></vector<long></vector<int></p>
</blockquote>
<p>56、合并区间</p>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<blockquote>
<p> vector<interval> merge(vector<interval>&amp; intervals) {<br>        if (intervals.empty()) return {};<br>        sort(intervals.begin(), intervals.end(), <a href="Interval &amp;a, Interval &amp;b"></a> {return a.start &lt; b.start;});<br>        vector<interval> res{intervals[0]};<br>        for (int i = 1; i &lt; intervals.size(); ++i) {<br>            if (res.back().end &lt; intervals[i].start) {<br>                res.push_back(intervals[i]);<br>            } else {<br>                res.back().end = max(res.back().end, intervals[i].end);<br>            }<br>        }<br>        return res;<br>    }</interval></interval></interval></p>
</blockquote>
<p>80、删除排序数组中的重复项||</p>
<p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>解法：做一个标记(flag)，记录那些出现过但是次数没有达到2次的元素</p>
<blockquote>
<p>int removeDuplicates(vector<int>&amp; nums) {<br>        if(nums.size()&lt;2){<br>            return nums.size();<br>        }<br>        int tmp=nums[0];<br>        int  flag=0;//标记<br>        for(int i=1;i&lt;nums.size();i++){<br>            if(nums[i]==tmp){//相等的时候<br>                if(flag==0){<br>                    flag=1;<br>                }else{<br>                    nums.erase(nums.begin()+i);<br>                    i–;<br>                }<br>            }else{<br>                tmp=nums[i];<br>                flag=0;<br>            }</int></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    &#125;</div><div class="line">    return nums.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>101、对称二叉树</p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>解法：递归判断 root-&gt;left-&gt;left和root-&gt;right-&gt;right对应</p>
<blockquote>
<p>bool isSymmetric(TreeNode<em> root) {<br>     if (!root) return true;<br>        return isSymmetric(root-&gt;left, root-&gt;right);<br>    }<br>bool isSymmetric(TreeNode </em>left, TreeNode *right) {<br>        if (!left &amp;&amp; !right) return true;<br>        if (left &amp;&amp; !right || !left &amp;&amp; right || left-&gt;val != right-&gt;val) return false;<br>        return isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;left);<br>    }</p>
</blockquote>
<p>137、只出现一次的数字II</p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>解法：建立一个32位的数字(int型)，来统计每一位上1出现的个数。如果某一位上为1的话，那么如果该整数出现了3次，对3去余则为0，若出现4次则为1，我们把每个数的对应位都加起来对3取余，最终剩下来的那个数就是单独的数字</p>
<blockquote>
<p>int singleNumber(vector<int>&amp; nums) {<br>      int res = 0;<br>        for (int i = 0; i &lt; 32; ++i) {<br>            int sum = 0;<br>            for (int j = 0; j &lt; nums.size(); ++j) {<br>                sum += (nums[j] &gt;&gt; i) &amp; 1;<br>            }<br>            res |= (sum % 3) &lt;&lt; i;<br>        }<br>        return res;<br>    }</int></p>
</blockquote>
<p>152、乘积最大子序列</p>
<p>给定一个整数数组 <code>nums</code> (包含负数、0)，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
<p>解法：使用动态规划，因为很小的负数乘一个负数会成一个很大的正数，因此建立两个数组，一个记录连乘最小的数，一个记录连乘最大的数。</p>
<blockquote>
<p>//<a href="http://www.cnblogs.com/grandyang/p/4028713.html" target="_blank" rel="external">http://www.cnblogs.com/grandyang/p/4028713.html</a><br>    int maxProduct(vector<int>&amp; nums) {<br>        int n=nums.size();<br>        int res=nums[0];<br>        vector<int>dp_max(n,0),dp_min(n,0);<br>        dp_max[0]=res;<br>        dp_min[0]=res;<br>        for(int i=1;i&lt;nums.size();i++){<br>           dp_max[i]=max(nums[i],max(nums[i]<em>dp_max[i-1],nums[i]</em>dp_min[i-1]));<br>           dp_min[i]=min(nums[i],min(nums[i]<em>dp_max[i-1],nums[i]</em>dp_min[i-1]));<br>           res=max(res,dp_max[i]);<br>        }<br>        return res;<br>    }</int></int></p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/13/Java中extend与implements的区别/" rel="next" title="Java中extend与implements的区别">
                <i class="fa fa-chevron-left"></i> Java中extend与implements的区别
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/panpan.jpg"
                alt="CoderZWei" />
            
              <p class="site-author-name" itemprop="name">CoderZWei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoderZWei</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
